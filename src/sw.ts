import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { set, get, del } from 'idb-keyval';

declare let self: ServiceWorkerGlobalScope;

// Precache all assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST);

// Cache Supabase API requests
registerRoute(
  ({ url }) => url.origin === 'https://kxpeuyomuohexsvcxneu.supabase.co',
  new NetworkFirst({
    cacheName: 'supabase-api-cache',
    networkTimeoutSeconds: 30, // Increased from 10s
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24,
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// Cache static assets
registerRoute(
  ({ request }) => request.destination === 'image' || request.destination === 'style' || request.destination === 'script',
  new CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 30,
      }),
    ],
  })
);

// Handle navigation requests
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: 'pages',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24,
      }),
    ],
  })
);

// Geolocation tracking logic
let isOnDuty = false;
let isOnline = navigator.onLine;
let locationInterval: NodeJS.Timeout | null = null;

// self.addEventListener('message', async (event) => {
//   if (event.data.type === 'SET_DUTY_STATUS') {
//     isOnDuty = event.data.isOnDuty;
//     if (isOnDuty && isOnline) {
//       startLocationTracking();
//     } else {
//       stopLocationTracking();
//     }
//   }
//   if (event.data.type === 'SET_USER_ID') {
//     self.userId = event.data.userId; // Store user ID
//   }
// });

self.addEventListener('message', async (event) => {
  try {
    if (event.data.type === 'SET_DUTY_STATUS') {
      isOnDuty = event.data.isOnDuty;
      if (isOnDuty && isOnline) {
        startLocationTracking();
      } else {
        stopLocationTracking();
      }
    }
    if (event.data.type === 'SET_USER_ID') {
      self.userId = event.data.userId;
    }
    // Acknowledge message to prevent port closure
    event.ports[0]?.postMessage({ status: 'received' });
  } catch (error) {
    console.error('Service worker message error:', error);
  }
});

// Handle online/offline status
self.addEventListener('online', () => {
  isOnline = true;
  if (isOnDuty) {
    startLocationTracking();
    syncOfflineData();
  }
});

self.addEventListener('offline', () => {
  isOnline = false;
  stopLocationTracking();
});

function startLocationTracking() {
  if (locationInterval) clearInterval(locationInterval);
  locationInterval = setInterval(() => {
    navigator.geolocation.getCurrentPosition(
      async (position) => {
        const { latitude, longitude } = position.coords;
        const locationData = {
          lat: latitude,
          lng: longitude,
          recorded_at: new Date().toISOString(),
          user_id: self.userId || null, // Use stored user ID
        };

        if (isOnline) {
          try {
            await sendToSupabase(locationData);
          } catch (error) {
            console.error('Failed to send to Supabase, storing offline:', error);
            await storeOffline(locationData);
          }
        } else {
          await storeOffline(locationData);
        }
      },
      (error) => console.error('Geolocation error:', error),
      { enableHighAccuracy: true }
    );
  }, 10 * 60 * 1000); // Every 10 minutes
}

function stopLocationTracking() {
  if (locationInterval) {
    clearInterval(locationInterval);
    locationInterval = null;
  }
}

async function storeOffline(data: { lat: number; lng: number; recorded_at: string; user_id: string | null }) {
  const offlineData = (await get('offline-locations')) || [];
  offlineData.push(data);
  await set('offline-locations', offlineData);
}

async function sendToSupabase(data: { lat: number; lng: number; recorded_at: string; user_id: string | null }) {
  const response = await fetch(`${import.meta.env.VITE_SUPABASE_URL}/rest/v1/loc_agent_locations`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${import.meta.env.VITE_SUPABASE_KEY}`,
      'apikey': import.meta.env.VITE_SUPABASE_KEY,
    },
    body: JSON.stringify(data),
  });
  if (!response.ok) throw new Error('Failed to send to Supabase');
}

async function syncOfflineData() {
  const offlineData = await get('offline-locations');
  if (offlineData && offlineData.length > 0) {
    for (const data of offlineData) {
      try {
        await sendToSupabase(data);
        const updatedData = offlineData.filter((item: any) => item !== data);
        await set('offline-locations', updatedData);
      } catch (error) {
        console.error('Sync failed:', error);
      }
    }
  }
}

// Skip waiting and claim clients
self.skipWaiting();
self.clients.claim();



// ... (Your existing code)

// Listen for the push event
self.addEventListener('push', (event) => {
  // Parse the push data
  const data = event.data?.json() || {};
  const { title = 'New Notification', message, url = '/' } = data;

  // Define the notification options
  const options = {
    body: message || 'You have a new notification.',
    icon: '/pwa-192x192.png', // Or another icon from your manifest
    badge: '/favicon-48x48.png',
    data: { url } // Custom data to use on notification click
  };

  // Show the notification. The waitUntil() method ensures the service worker doesn't
  // terminate until the notification is displayed.
  event.waitUntil(self.registration.showNotification(title, options));
});

// Listen for the notification click event
self.addEventListener('notificationclick', (event) => {
  event.notification.close(); // Close the notification

  const urlToOpen = event.notification.data?.url || '/';

  event.waitUntil(
    // Get all window clients
    self.clients.matchAll({ type: 'window' }).then((clients) => {
      for (const client of clients) {
        // Check if a client with the correct URL is already open
        if (client.url === urlToOpen && 'focus' in client) {
          return client.focus(); // Focus on the existing tab
        }
      }
      // If no matching client is open, open a new one
      if (self.clients.openWindow) {
        return self.clients.openWindow(urlToOpen);
      }
    })
  );
});

// Add these to the top of your sw.ts file for push notification-specific types
interface PushNotificationData {
  title: string;
  message: string;
  url?: string;
}

declare global {
  interface NotificationEventMap {
    'push': PushEvent;
  }
}

// ... (Your existing code)