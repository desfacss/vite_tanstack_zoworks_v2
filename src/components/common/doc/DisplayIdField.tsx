import React, { useState, useEffect, useCallback, useRef } from 'react';
import { 
  Input, 
  Button, 
  Tooltip, 
  message,
  InputNumber 
} from 'antd';
import { 
  EditOutlined, 
  CheckCircleOutlined, 
  LoadingOutlined, 
  CloseCircleOutlined, 
  SyncOutlined,
  LockOutlined
} from '@ant-design/icons';
import { DisplayIdService } from './services/displayIdService';
import { DisplayIdConfig } from './types/displayId';
import { useAuthStore } from '@/core/lib/store';

// Simple debounce utility function
function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout;
  return (...args: Parameters<T>) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
}

interface DisplayIdFieldProps {
  entityType: string;
  value?: string;
  onChange?: (value: string) => void;
  formData?: Record<string, any>;
  disabled?: boolean;
  placeholder?: string;
}

const DisplayIdField: React.FC<DisplayIdFieldProps> = ({
  entityType,
  entitySchema,
  value,
  onChange,
  formData,
  disabled,
  placeholder
}) => {
  const { organization,location } = useAuthStore();
  const [isAutoGenerated, setIsAutoGenerated] = useState(true);
  const [isEditable, setIsEditable] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [lastGeneratedFor, setLastGeneratedFor] = useState<string>('');
  const [isValidating, setIsValidating] = useState(false);
  const [config, setConfig] = useState<DisplayIdConfig | null>(null);
  const [validationResult, setValidationResult] = useState<{
    isValid: boolean;
    message?: string;
  } | null>(null);
  const [canGenerate, setCanGenerate] = useState(false);
  const [counterValue, setCounterValue] = useState<number>(1);
  const [displayPrefix, setDisplayPrefix] = useState<string>('');
  const isInitialMount = useRef(true);

  // Load configuration on mount
  useEffect(() => {
    const loadConfig = async () => {
      const config = await DisplayIdService.getConfig(entityType,organization?.id);
      setConfig(config);
    };
    loadConfig();
  }, [entityType]);

  // Reset state when entityType changes
  useEffect(() => {
    setIsAutoGenerated(true);
    setIsEditable(false);
  }, [entityType]);

  // Check if we can generate display ID based on available form data
  useEffect(() => {
    if (config && formData) {
      const canGenerate = DisplayIdService.canGenerate(config, formData);
      setCanGenerate(canGenerate);
    }
  }, [config, formData]);

  // Parse display ID to extract counter and prefix
  useEffect(() => {
    if (value && config) {
      const { prefix, counter } = parseDisplayId(value, config);
      setDisplayPrefix(prefix);
      setCounterValue(counter);
    }
  }, [value, config]);

  // Auto-generate display ID when conditions are met
  useEffect(() => {
    // Skip auto-generation on initial mount if value already exists
    if (isInitialMount.current) {
      isInitialMount.current = false;
      if (value) {
        setIsAutoGenerated(false);
        setIsEditable(true);
        return;
      }
    }

    // Create a key from form data to detect changes
    const formDataKey = JSON.stringify(formData);
    
    if (isAutoGenerated && canGenerate && config && formDataKey !== lastGeneratedFor) {
      setLastGeneratedFor(formDataKey);
      generateDisplayId();
    }
  }, [isAutoGenerated, canGenerate, config, formData, lastGeneratedFor]);

  // Debounced validation for manual input
  const debouncedValidation = useCallback(
    debounce(async (value: string) => {
      if (!value) return;

      setIsValidating(true);
      try {
        const result = await DisplayIdService.validate(entityType, value);
        setValidationResult(result);
      } catch (error) {
        setValidationResult({ isValid: false, message: 'Validation failed' });
      } finally {
        setIsValidating(false);
      }
    }, 500),
    [entityType]
  );

  // Trigger validation when value changes and not auto-generated
  useEffect(() => {
    if (value && !isAutoGenerated) {
      debouncedValidation(value);
    }
  }, [value, isAutoGenerated, debouncedValidation]);

  const parseDisplayId = (displayId: string, config: DisplayIdConfig) => {
    // Find the counter token in the format
    const counterToken = config.token_config.find(token => token.type === 'counter');
    if (!counterToken) {
      return { prefix: displayId, counter: 1 };
    }

    // Extract counter from the end of the display ID
    const counterMatch = displayId.match(/(\d+)$/);
    if (counterMatch) {
      const counter = parseInt(counterMatch[1], 10);
      const prefix = displayId.substring(0, displayId.length - counterMatch[1].length);
      return { prefix, counter };
    }

    return { prefix: displayId, counter: 1 };
  };

  const generateDisplayIdWithCounter = async (customCounter?: number) => {
    if (!config || !canGenerate) return null;

    try {
      // Generate the full display ID first
      const generatedId = await DisplayIdService.generateDisplayIdForNewRecord(
        entityType,
        entitySchema,
        formData || {},
        organization?.id,
        location?.id,
      );

      if (generatedId && customCounter !== undefined) {
        // Replace the counter part with custom value
        const { prefix } = parseDisplayId(generatedId, config);
        const paddedCounter = customCounter.toString().padStart(config.counter_padding || 4, '0');
        return prefix + paddedCounter;
      }

      return generatedId;
    } catch (error) {
      console.error('Error generating display ID:', error);
      return null;
    }
  };

  const generateDisplayId = async () => {
    if (!config || !canGenerate || isGenerating) return;

    setIsGenerating(true);
    try {
      const generatedId = await generateDisplayIdWithCounter();
      if (generatedId) {
        onChange?.(generatedId);
        const { prefix, counter } = parseDisplayId(generatedId, config);
        setDisplayPrefix(prefix);
        setCounterValue(counter);
      }
    } catch (error) {
      message.error('Failed to generate Display ID');
    } finally {
      setIsGenerating(false);
    }
  };

  const handleEditToggle = () => {
    if (isEditable) {
      // Switching back to auto-generation
      setLastGeneratedFor(''); // Reset to force regeneration
      setIsEditable(false);
      setIsAutoGenerated(true);
      setValidationResult(null);
      if (canGenerate) {
        generateDisplayId();
      }
    } else {
      // Switching to manual edit
      setIsEditable(true);
      setIsAutoGenerated(false);
    }
  };

  const handleCounterChange = async (newCounter: number | null) => {
    if (!newCounter || !config || disabled) return;

    setCounterValue(newCounter);
    
    // Generate new display ID with custom counter
    const newDisplayId = await generateDisplayIdWithCounter(newCounter);
    if (newDisplayId) {
      onChange?.(newDisplayId);
      setIsAutoGenerated(false); // Mark as manually edited
    }
  };

  const handleRegenerateClick = () => {
    if (canGenerate) {
      generateDisplayId();
    } else {
      message.warning('Please fill in required fields to generate Display ID');
      console.log('Cannot generate - missing required fields:', DisplayIdService.getRequiredFields(config));
    }
  };

  const getStatusIcon = () => {
    if (isGenerating) {
      return <LoadingOutlined />;
    }

    if (isValidating) {
      return <SyncOutlined spin />;
    }

    if (validationResult) {
      if (validationResult.isValid) {
        return (
          <Tooltip title="Valid Display ID">
            <CheckCircleOutlined style={{ color: '#52c41a' }} />
          </Tooltip>
        );
      } else {
        return (
          <Tooltip title={validationResult.message || 'Invalid Display ID'}>
            <CloseCircleOutlined style={{ color: '#ff4d4f' }} />
          </Tooltip>
        );
      }
    }

    if (isAutoGenerated && !isEditable) {
      return (
        <Tooltip title="Auto-generated">
          <LockOutlined style={{ color: '#1890ff' }} />
        </Tooltip>
      );
    }

    return null;
  };

  const getEditButton = () => {
    if (disabled) return null;

    return (
      <Button
        type="text"
        icon={<EditOutlined />}
        onClick={handleEditToggle}
        style={{ marginLeft: 8 }}
        size="small"
      >
        {isEditable ? 'Auto' : 'Edit'}
      </Button>
    );
  };

  const getRegenerateButton = () => {
    if (disabled || !isAutoGenerated) return null;

    return (
      <Button
        type="text"
        icon={<SyncOutlined />}
        onClick={handleRegenerateClick}
        loading={isGenerating}
        style={{ marginLeft: 8 }}
        size="small"
      >
        Regenerate
      </Button>
    );
  };

  // Render the display ID field
  if (isEditable && !isAutoGenerated && displayPrefix) {
    // Show prefix as read-only text + editable counter
    return (
      <div style={{ display: 'flex', alignItems: 'center' }}>
        <div style={{ flex: 1, display: 'flex', alignItems: 'center' }}>
          <span style={{ 
            padding: '4px 8px',
            backgroundColor: '#f5f5f5',
            border: '1px solid #d9d9d9',
            borderRight: 'none',
            borderRadius: '6px 0 0 6px',
            color: '#666',
            fontSize: '14px'
          }}>
            {displayPrefix}
          </span>
          <InputNumber
            value={counterValue}
            onChange={handleCounterChange}
            min={1}
            max={9999}
            disabled={disabled}
            style={{ 
              borderRadius: '0 6px 6px 0',
              borderLeft: 'none'
            }}
            controls={false}
          />
          <div style={{ marginLeft: 8 }}>
            {getStatusIcon()}
          </div>
        </div>
        {getEditButton()}
        {getRegenerateButton()}
      </div>
    );
  }

  // Default input for full display ID (read-only or when no prefix available)
  return (
    <div style={{ display: 'flex', alignItems: 'center' }}>
      <div style={{ flex: 1 }}>
        <Input
          value={value || ''}
          placeholder={placeholder || (canGenerate ? 'Generating...' : 'Fill required fields to generate')}
          disabled={disabled || (isAutoGenerated && !isEditable)}
          status={validationResult && !validationResult.isValid ? 'error' : undefined}
          suffix={getStatusIcon()}
          readOnly={true} // Always read-only since we handle counter editing separately
        />
      </div>
      {getEditButton()}
      {getRegenerateButton()}
    </div>
  );
};

export default DisplayIdField;