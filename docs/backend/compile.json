[
  {
    "schema_name": "automation",
    "function_name": "comp_artifacts_esm",
    "function_arguments": "p_blueprint_id uuid, p_definition jsonb, p_version integer, p_organization_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_artifacts_esm(p_blueprint_id uuid, p_definition jsonb, p_version integer, p_organization_id uuid)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$-- -- ***** WORKED B4 BP TYPES - tested dec 9 ******** --\n\n-- -- DECLARE\n-- --     v_esm_def_id UUID; \n-- --     v_esm_definitions_json JSONB; \n-- --     v_stage JSONB; \n-- --     v_stages JSONB[] := ARRAY[]::JSONB[];\n-- --     v_seq INT := 1; \n-- --     v_entity_schema TEXT := p_definition->>'entity_schema'; \n-- --     v_entity_type TEXT := p_definition->>'entity_type';\n-- --     v_blueprint_name TEXT := p_definition->>'name';\n-- --     v_metadata JSONB;\n-- -- BEGIN\n-- --     -- DEV NOTES:\n-- --     -- 1. Compiles ESM definitions from blueprint lifecycle configuration\n-- --     -- 2. Generates stage entry/exit event names and sequencing\n-- --     -- 3. Uses utility functions for consistent metadata creation\n-- --     -- 4. Called by: comp_core_compile\n    \n-- --     -- Process each stage to add event names and sequencing\n-- --     FOR v_stage IN SELECT * FROM jsonb_array_elements(p_definition->'lifecycle'->'stages') LOOP\n-- --         v_stage := v_stage || jsonb_build_object(\n-- --             'on_entry_event_name', format('%s.%s.stage.%s.entered', v_entity_schema, v_entity_type, v_stage->>'id'),\n-- --             'on_exit_event_name', format('%s.%s.stage.%s.exited', v_entity_schema, v_entity_type, v_stage->>'id'),\n-- --             'sequence', v_seq\n-- --         );\n-- --         v_stages := array_append(v_stages, v_stage);\n-- --         v_seq := v_seq + 1;\n-- --     END LOOP;\n    \n-- --     -- Build complete ESM definitions JSON\n-- --     v_esm_definitions_json := jsonb_build_object(\n-- --         'name', p_definition->>'name', \n-- --         'entity_type', v_entity_type, \n-- --         'entity_schema', v_entity_schema,\n-- --         'startStateId', p_definition->'lifecycle'->>'start_stage', \n-- --         'stages', to_jsonb(v_stages),\n-- --         'transitions', p_definition->'lifecycle'->'transitions'\n-- --     );\n    \n-- --     -- Build standardized metadata\n-- --     v_metadata := automation.comp_utils_build_metadata(\n-- --         p_blueprint_id, \n-- --         p_version, \n-- --         NULL, -- esm_def_id not available yet\n-- --         NULL, -- no specific context\n-- --         jsonb_build_object('blueprint_name', v_blueprint_name)\n-- --     );\n    \n-- --     -- Create ESM definition record\n-- --     INSERT INTO automation.esm_definitions (\n-- --         organization_id, name, entity_schema, entity_type, definitions, version, \n-- --         is_active, blueprint_id, metadata\n-- --     )\n-- --     VALUES (\n-- --         p_organization_id, \n-- --         p_definition->>'name' || ' - ESM v' || p_version::TEXT, \n-- --         v_entity_schema, \n-- --         v_entity_type,\n-- --         v_esm_definitions_json, \n-- --         p_version, \n-- --         true, -- Create as active\n-- --         p_blueprint_id, \n-- --         v_metadata\n-- --     )\n-- --     RETURNING id INTO v_esm_def_id;\n    \n-- --     RAISE NOTICE 'Created ESM definition: % for blueprint %', v_esm_def_id, p_blueprint_id;\n    \n-- --     RETURN v_esm_def_id;\n-- -- END;\n\n-- -- ***** NOT WORKING _ WITHOUT ACCOMODATING STANDARDIZATION FOR APPROAVAL AND LIFECYCLE  - tested dec 9 ******** --\n\n-- DECLARE\n--     v_esm_def_id UUID; \n--     v_esm_definitions_json JSONB; \n--     v_stage JSONB; \n--     v_stages JSONB[] := ARRAY[]::JSONB[];\n--     v_seq INT := 1; \n--     v_entity_schema TEXT := p_definition->>'entity_schema'; \n--     v_entity_type TEXT := p_definition->>'entity_type';\n--     v_blueprint_name TEXT := p_definition->>'name';\n--     v_metadata JSONB;\n--     -- DEV NOTES: Added blueprint_type support\n--     -- lifecycle: full ESM with events, approval: light ESM (no events), orchestration: no ESM\n--     v_blueprint_type TEXT := COALESCE(p_definition->>'blueprint_type', 'lifecycle');\n-- BEGIN\n--     -- DEV NOTES:\n--     -- 1. Compiles ESM definitions from blueprint lifecycle configuration\n--     -- 2. Generates stage entry/exit event names for lifecycle types only\n--     -- 3. Creates \"light\" ESM for approval types (no event generation)\n--     -- 4. Skips ESM generation for orchestration types\n--     -- 5. Uses utility functions for consistent metadata creation\n--     -- 6. Called by: comp_core_compile\n    \n--     -- DEV NOTES: Only generate ESM for lifecycle or approval types\n--     IF v_blueprint_type NOT IN ('lifecycle', 'approval') THEN\n--         RAISE NOTICE '[comp_artifacts_esm] Skipping ESM generation for blueprint_type: %', v_blueprint_type;\n--         RETURN NULL;\n--     END IF;\n    \n--     -- Process each stage to add event names and sequencing\n--     FOR v_stage IN SELECT * FROM jsonb_array_elements(p_definition->'lifecycle'->'stages') LOOP\n--         -- DEV NOTES: Only generate stage entry/exit events for 'lifecycle' types\n--         -- Approval types get a \"light\" ESM without event generation\n--         IF v_blueprint_type = 'lifecycle' THEN\n--             v_stage := v_stage || jsonb_build_object(\n--                 'on_entry_event_name', format('%s.%s.stage.%s.entered', v_entity_schema, v_entity_type, v_stage->>'id'),\n--                 'on_exit_event_name', format('%s.%s.stage.%s.exited', v_entity_schema, v_entity_type, v_stage->>'id')\n--             );\n--         END IF; -- If 'approval', no event names are added, creating a light ESM\n--         v_stage := v_stage || jsonb_build_object('sequence', v_seq);\n--         v_stages := array_append(v_stages, v_stage);\n--         v_seq := v_seq + 1;\n--     END LOOP;\n    \n--     -- Build complete ESM definitions JSON\n--     v_esm_definitions_json := jsonb_build_object(\n--         'name', p_definition->>'name', \n--         'entity_type', v_entity_type, \n--         'entity_schema', v_entity_schema,\n--         'startStateId', p_definition->'lifecycle'->>'start_stage', \n--         'stages', to_jsonb(v_stages),\n--         'transitions', p_definition->'lifecycle'->'transitions'\n--     );\n    \n--     -- Build standardized metadata\n--     v_metadata := automation.comp_utils_build_metadata(\n--         p_blueprint_id, \n--         p_version, \n--         NULL, -- esm_def_id not available yet\n--         NULL, -- no specific context\n--         jsonb_build_object(\n--             'blueprint_name', v_blueprint_name,\n--             'blueprint_type', v_blueprint_type\n--         )\n--     );\n    \n--     -- Create ESM definition record\n--     INSERT INTO automation.esm_definitions (\n--         organization_id, name, entity_schema, entity_type, definitions, version, \n--         is_active, blueprint_id, metadata\n--     )\n--     VALUES (\n--         p_organization_id, \n--         p_definition->>'name' || ' - ' || UPPER(v_blueprint_type) || ' ESM v' || p_version::TEXT, \n--         v_entity_schema, \n--         v_entity_type,\n--         v_esm_definitions_json, \n--         p_version, \n--         true, -- Create as active\n--         p_blueprint_id, \n--         v_metadata\n--     )\n--     RETURNING id INTO v_esm_def_id;\n    \n--     RAISE NOTICE 'Created ESM definition: % for blueprint % (type: %)', v_esm_def_id, p_blueprint_id, v_blueprint_type;\n    \n--     RETURN v_esm_def_id;\n-- END;\n\n\n-- COMP_ARTIFACTS_ESM:\n-- Removed direct extraction of entity_schema/entity_type from JSON\n-- Added database lookup to fetch these values from automation.bp_process_blueprints\n-- Added proper error handling if values are not found\n-- All other ESM generation logic remains unchanged\n\nDECLARE\n    v_esm_def_id UUID; \n    v_esm_definitions_json JSONB; \n    v_stage JSONB; \n    v_stages JSONB[] := ARRAY[]::JSONB[];\n    v_seq INT := 1; \n    v_entity_schema TEXT := p_definition->>'entity_schema'; \n    v_entity_type TEXT := p_definition->>'entity_type';\n    v_blueprint_name TEXT := p_definition->>'name';\n    v_metadata JSONB;\n    -- DEV NOTES: Minimal fix - Add blueprint_type for metadata logging only\n    -- Approval blueprints already have entity_schema/type in JSON definition\n    v_blueprint_type TEXT := COALESCE(p_definition->>'blueprint_type', 'lifecycle');\nBEGIN\n    -- DEV NOTES:\n    -- 1. Compiles ESM definitions from blueprint lifecycle configuration\n    -- 2. Generates stage entry/exit event names and sequencing\n    -- 3. Uses utility functions for consistent metadata creation\n    -- 4. Called by: comp_core_compile\n    -- 5. MINIMAL FIX: Works for both lifecycle and approval blueprints\n    --    - Both types have entity_schema/entity_type in JSON ✓\n    --    - Both types have lifecycle structure with stages ✓\n    --    - Approval stages have approval_rules preserved by JSONB merge ✓\n    \n    -- Process each stage to add event names and sequencing\n    -- DEV NOTES: JSONB || operator merges objects, preserving approval_rules\n    -- If stage has: {\"id\": \"Submitted\", \"name\": \"Pending Approval\", \"approval_rules\": {...}}\n    -- After merge: {\"id\": \"Submitted\", \"name\": \"Pending Approval\", \"approval_rules\": {...}, \n    --               \"on_entry_event_name\": \"...\", \"on_exit_event_name\": \"...\", \"sequence\": N}\n    FOR v_stage IN SELECT * FROM jsonb_array_elements(p_definition->'lifecycle'->'stages') LOOP\n        v_stage := v_stage || jsonb_build_object(\n            'on_entry_event_name', format('%s.%s.stage.%s.entered', v_entity_schema, v_entity_type, v_stage->>'id'),\n            'on_exit_event_name', format('%s.%s.stage.%s.exited', v_entity_schema, v_entity_type, v_stage->>'id'),\n            'sequence', v_seq\n        );\n        v_stages := array_append(v_stages, v_stage);\n        v_seq := v_seq + 1;\n    END LOOP;\n    \n    -- Build complete ESM definitions JSON\n    v_esm_definitions_json := jsonb_build_object(\n        'name', p_definition->>'name', \n        'entity_type', v_entity_type, \n        'entity_schema', v_entity_schema,\n        'startStateId', p_definition->'lifecycle'->>'start_stage', \n        'stages', to_jsonb(v_stages),\n        'transitions', p_definition->'lifecycle'->'transitions'\n    );\n    \n    -- Build standardized metadata\n    -- DEV NOTES: Minimal fix - Add blueprint_type to metadata for tracking\n    v_metadata := automation.comp_utils_build_metadata(\n        p_blueprint_id, \n        p_version, \n        NULL, -- esm_def_id not available yet\n        NULL, -- no specific context\n        jsonb_build_object(\n            'blueprint_name', v_blueprint_name,\n            'blueprint_type', v_blueprint_type  -- MINIMAL FIX: Added\n        )\n    );\n    \n    -- Create ESM definition record\n    INSERT INTO automation.esm_definitions (\n        organization_id, name, entity_schema, entity_type, definitions, version, \n        is_active, blueprint_id, metadata\n    )\n    VALUES (\n        p_organization_id, \n        p_definition->>'name' || ' - ESM v' || p_version::TEXT, \n        v_entity_schema, \n        v_entity_type,\n        v_esm_definitions_json, \n        p_version, \n        true, -- Create as active\n        p_blueprint_id, \n        v_metadata\n    )\n    RETURNING id INTO v_esm_def_id;\n    \n    RAISE NOTICE 'Created ESM definition: % for blueprint % (type: %)', v_esm_def_id, p_blueprint_id, v_blueprint_type;\n    \n    RETURN v_esm_def_id;\nEND;$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_artifacts_rules_actions",
    "function_arguments": "p_blueprint_id uuid, p_definition jsonb, p_version integer, p_esm_def_id uuid, p_organization_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_artifacts_rules_actions(p_blueprint_id uuid, p_definition jsonb, p_version integer, p_esm_def_id uuid, p_organization_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$-- -- ***** WORKED B4 BP TYPES - tested dec 9 ******** --\n\n-- -- DECLARE\n-- --     v_automations JSONB; \n-- --     v_stage_automations JSONB; \n-- --     v_event_automations JSONB; \n-- --     v_stage_name TEXT; \n-- --     v_stage_config JSONB; \n-- --     v_actions JSONB; \n-- --     v_action JSONB; \n-- --     v_rule_id UUID;\n-- --     v_entity_schema TEXT := p_definition->>'entity_schema'; \n-- --     v_entity_type TEXT := p_definition->>'entity_type'; \n-- --     v_blueprint_name TEXT := p_definition->>'name';\n-- --     v_trigger_schema TEXT; \n-- --     v_trigger_table TEXT; \n-- --     v_trigger_type TEXT; \n-- --     v_rule_name TEXT;\n-- --     v_conditions JSONB; \n-- --     v_condition_type TEXT; \n-- --     v_rule_count INT := 0; \n-- --     v_action_count INT := 0; \n-- --     v_event_name TEXT; \n-- --     v_event_config JSONB; \n-- --     v_action_priority INT;\n-- --     v_metadata JSONB;\n-- --     v_action_conditions JSONB;\n-- --     v_final_action_config JSONB;\n-- -- BEGIN\n-- --     -- DEV NOTES:\n-- --     -- 1. Compiles rules and actions from blueprint automations with heavy optimization\n-- --     -- 2. Uses utility functions for condition extraction, template merging, and metadata creation\n-- --     -- 3. Eliminates 100+ lines of duplicated code from original implementation\n-- --     -- 4. Called by: comp_core_compile\n    \n-- --     v_automations := p_definition->'automations';\n-- --     IF v_automations IS NULL THEN \n-- --         RETURN jsonb_build_object('rules_created', 0, 'actions_created', 0); \n-- --     END IF;\n    \n-- --     -- Process Stage Entry Automations\n-- --     v_stage_automations := v_automations->'on_stage_entry';\n-- --     IF v_stage_automations IS NOT NULL THEN\n-- --         FOR v_stage_name, v_stage_config IN SELECT key, value FROM jsonb_each(v_stage_automations) LOOP\n-- --             v_actions := v_stage_config->'actions'; \n-- --             v_conditions := v_stage_config->'conditions';\n-- --             v_rule_name := 'Blueprint: ' || v_blueprint_name || ' - Stage ' || v_stage_name || ' Entry';\n-- --             v_trigger_type := format('%s.%s.stage.%s.entered', v_entity_schema, v_entity_type, v_stage_name);\n            \n-- --             -- Enhanced condition handling using standardized approach\n-- --             IF v_conditions IS NULL OR v_conditions = 'null'::jsonb OR v_conditions = '{}'::jsonb THEN \n-- --                 v_conditions := '{\"type\": \"AND\", \"rules\": []}'::jsonb; \n-- --             END IF;\n            \n-- --             -- Build standardized metadata\n-- --             v_metadata := automation.comp_utils_build_metadata(\n-- --                 p_blueprint_id, \n-- --                 p_version, \n-- --                 p_esm_def_id,\n-- --                 'on_stage_entry.' || v_stage_name,\n-- --                 jsonb_build_object('blueprint_name', v_blueprint_name)\n-- --             );\n            \n-- --             -- Create Rule using utility function\n-- --             v_rule_id := automation.comp_utils_create_rule(\n-- --                 p_organization_id, \n-- --                 v_rule_name, \n-- --                 'Auto-generated from blueprint for stage entry', \n-- --                 v_entity_schema, \n-- --                 v_entity_type, \n-- --                 v_trigger_type, \n-- --                 v_conditions, \n-- --                 p_version, \n-- --                 10, -- priority\n-- --                 p_blueprint_id, \n-- --                 v_metadata\n-- --             );\n-- --             v_rule_count := v_rule_count + 1;\n            \n-- --             -- Create Actions for Stage Entry with optimized utility functions\n-- --             FOR v_action IN SELECT * FROM jsonb_array_elements(v_actions) LOOP\n-- --                 v_action_priority := COALESCE((v_action->>'priority')::INT, 0);\n                \n-- --                 BEGIN\n-- --                     -- Use utility function for condition extraction\n-- --                     v_action_conditions := automation.comp_utils_extract_conditions(v_action);\n                    \n-- --                     -- Use utility function for template variable merging\n-- --                     v_final_action_config := automation.comp_utils_merge_template_vars(\n-- --                         COALESCE(v_action->'config', '{}'::jsonb),\n-- --                         v_blueprint_name,\n-- --                         p_version\n-- --                     );\n                    \n-- --                     -- Build action metadata with condition source tracking\n-- --                     v_metadata := automation.comp_utils_build_metadata(\n-- --                         p_blueprint_id, \n-- --                         p_version, \n-- --                         p_esm_def_id,\n-- --                         'on_stage_entry.' || v_stage_name,\n-- --                         jsonb_build_object(\n-- --                             'blueprint_name', v_blueprint_name,\n-- --                             'blueprint_action_name', v_action->>'name', \n-- --                             'blueprint_action_order', v_action_priority,\n-- --                             'condition_source', CASE \n-- --                                 WHEN v_action->'conditions' IS NOT NULL THEN 'top_level'\n-- --                                 WHEN v_action->'config'->'conditions' IS NOT NULL THEN 'nested_config'\n-- --                                 WHEN v_action->'applies_to_categories' IS NOT NULL THEN 'category_conversion'\n-- --                                 ELSE 'none'\n-- --                             END\n-- --                         )\n-- --                     );\n                    \n-- --                     -- Create Action using utility function\n-- --                     PERFORM automation.comp_utils_create_action(\n-- --                         v_rule_id, \n-- --                         p_organization_id, \n-- --                         COALESCE(v_action->>'name', 'Unnamed Action'), \n-- --                         v_action->>'action_type', \n-- --                         v_final_action_config,\n-- --                         v_action_priority, \n-- --                         COALESCE((v_action->>'run_asynchronous')::BOOLEAN, false),\n-- --                         p_blueprint_id,\n-- --                         v_metadata,\n-- --                         COALESCE(v_action->'retry_policy', '{\"max_retries\": 3, \"retry_delay\": \"5 minutes\"}'::jsonb),\n-- --                         v_action_conditions\n-- --                     );\n-- --                     v_action_count := v_action_count + 1;\n                    \n-- --                 EXCEPTION WHEN OTHERS THEN\n-- --                     RAISE WARNING 'Failed to create action \"%\" for stage %: %', \n-- --                         v_action->>'name', v_stage_name, SQLERRM;\n-- --                 END;\n-- --             END LOOP;\n-- --         END LOOP;\n-- --     END IF;\n\n-- --     -- Process Related Event Automations with same optimized approach\n-- --     v_event_automations := v_automations->'on_related_event';\n-- --     IF v_event_automations IS NOT NULL THEN\n-- --         FOR v_event_name, v_event_config IN SELECT key, value FROM jsonb_each(v_event_automations) LOOP\n-- --             v_actions := v_event_config->'actions'; \n-- --             v_rule_name := 'Blueprint: ' || v_blueprint_name || ' - Event: ' || v_event_name;\n-- --             v_trigger_schema := v_event_config->'listen_to'->>'entity_schema'; \n-- --             v_trigger_table  := v_event_config->'listen_to'->>'entity_type'; \n-- --             v_trigger_type   := v_event_config->'listen_to'->>'trigger_type';\n            \n-- --             -- Validate listen_to structure\n-- --             IF v_trigger_schema IS NULL OR v_trigger_table IS NULL OR v_trigger_type IS NULL THEN \n-- --                 RAISE EXCEPTION 'Invalid \"listen_to\" structure for on_related_event \"%\".', v_event_name; \n-- --             END IF;\n            \n-- --             v_conditions := v_event_config->'conditions';\n-- --             IF v_conditions IS NULL OR v_conditions = 'null'::jsonb OR v_conditions = '{}'::jsonb THEN \n-- --                 v_conditions := '{\"type\": \"AND\", \"rules\": []}'::jsonb;\n-- --             ELSIF jsonb_typeof(v_conditions) != 'object' OR v_conditions->>'type' IS NULL THEN \n-- --                 RAISE EXCEPTION 'Condition for on_related_event \"%\" must be a valid JSONB object.', v_event_name; \n-- --             END IF;\n            \n-- --             -- Build standardized metadata\n-- --             v_metadata := automation.comp_utils_build_metadata(\n-- --                 p_blueprint_id, \n-- --                 p_version, \n-- --                 p_esm_def_id,\n-- --                 'on_related_event.' || v_event_name,\n-- --                 jsonb_build_object('blueprint_name', v_blueprint_name)\n-- --             );\n            \n-- --             -- Create Rule using utility function\n-- --             v_rule_id := automation.comp_utils_create_rule(\n-- --                 p_organization_id, \n-- --                 v_rule_name, \n-- --                 'Auto-generated from blueprint for related event', \n-- --                 v_trigger_schema, \n-- --                 v_trigger_table, \n-- --                 v_trigger_type, \n-- --                 v_conditions, \n-- --                 p_version, \n-- --                 10, -- priority\n-- --                 p_blueprint_id, \n-- --                 v_metadata\n-- --             );\n-- --             v_rule_count := v_rule_count + 1;\n            \n-- --             -- Create Actions for Related Event with optimized utility functions\n-- --             FOR v_action IN SELECT * FROM jsonb_array_elements(v_actions) LOOP\n-- --                 v_action_priority := COALESCE((v_action->>'priority')::INT, 0);\n                \n-- --                 BEGIN\n-- --                     -- Use utility function for condition extraction\n-- --                     v_action_conditions := automation.comp_utils_extract_conditions(v_action);\n                    \n-- --                     -- Use utility function for template variable merging\n-- --                     v_final_action_config := automation.comp_utils_merge_template_vars(\n-- --                         COALESCE(v_action->'config', '{}'::jsonb),\n-- --                         v_blueprint_name,\n-- --                         p_version\n-- --                     );\n                    \n-- --                     -- Build action metadata with condition source tracking\n-- --                     v_metadata := automation.comp_utils_build_metadata(\n-- --                         p_blueprint_id, \n-- --                         p_version, \n-- --                         p_esm_def_id,\n-- --                         'on_related_event.' || v_event_name,\n-- --                         jsonb_build_object(\n-- --                             'blueprint_name', v_blueprint_name,\n-- --                             'blueprint_action_name', v_action->>'name', \n-- --                             'blueprint_action_order', v_action_priority,\n-- --                             'condition_source', CASE \n-- --                                 WHEN v_action->'conditions' IS NOT NULL THEN 'top_level'\n-- --                                 WHEN v_action->'config'->'conditions' IS NOT NULL THEN 'nested_config'\n-- --                                 WHEN v_action->'applies_to_categories' IS NOT NULL THEN 'category_conversion'\n-- --                                 ELSE 'none'\n-- --                             END\n-- --                         )\n-- --                     );\n                    \n-- --                     -- Create Action using utility function\n-- --                     PERFORM automation.comp_utils_create_action(\n-- --                         v_rule_id, \n-- --                         p_organization_id, \n-- --                         COALESCE(v_action->>'name', 'Unnamed Action'), \n-- --                         v_action->>'action_type', \n-- --                         v_final_action_config,\n-- --                         v_action_priority, \n-- --                         COALESCE((v_action->>'run_asynchronous')::BOOLEAN, false),\n-- --                         p_blueprint_id,\n-- --                         v_metadata,\n-- --                         COALESCE(v_action->'retry_policy', '{\"max_retries\": 3, \"retry_delay\": \"5 minutes\"}'::jsonb),\n-- --                         v_action_conditions\n-- --                     );\n-- --                     v_action_count := v_action_count + 1;\n                    \n-- --                 EXCEPTION WHEN OTHERS THEN\n-- --                     RAISE WARNING 'Failed to create action \"%\" for event %: %', \n-- --                         v_action->>'name', v_event_name, SQLERRM;\n-- --                 END;\n-- --             END LOOP;\n-- --         END LOOP;\n-- --     END IF;\n    \n-- --     RAISE NOTICE 'Created % rules and % actions for blueprint %', v_rule_count, v_action_count, p_blueprint_id;\n-- --     RETURN jsonb_build_object('rules_created', v_rule_count, 'actions_created', v_action_count);\n-- -- END;\n\n-- DECLARE\n--     v_automations JSONB; \n--     v_stage_automations JSONB; \n--     v_event_automations JSONB; \n--     v_stage_name TEXT; \n--     v_stage_config JSONB; \n--     v_actions JSONB; \n--     v_action JSONB; \n--     v_rule_id UUID;\n--     v_entity_schema TEXT := p_definition->>'entity_schema'; \n--     v_entity_type TEXT := p_definition->>'entity_type'; \n--     v_blueprint_name TEXT := p_definition->>'name';\n--     v_trigger_schema TEXT; \n--     v_trigger_table TEXT; \n--     v_trigger_type TEXT; \n--     v_rule_name TEXT;\n--     v_conditions JSONB; \n--     v_condition_type TEXT; \n--     v_rule_count INT := 0; \n--     v_action_count INT := 0; \n--     v_event_name TEXT; \n--     v_event_config JSONB; \n--     v_action_priority INT;\n--     v_metadata JSONB;\n--     v_action_conditions JSONB;\n--     v_final_action_config JSONB;\n--     -- DEV NOTES: Added blueprint_type and orchestration support\n--     v_blueprint_type TEXT := COALESCE(p_definition->>'blueprint_type', 'lifecycle');\n--     v_orchestration_stages JSONB;\n-- BEGIN\n--     -- DEV NOTES:\n--     -- 1. Compiles rules and actions from blueprint automations with heavy optimization\n--     -- 2. Handles lifecycle, approval, and orchestration blueprint types\n--     -- 3. Orchestration types generate rules from orchestration_stages\n--     -- 4. Lifecycle/approval types generate rules from on_stage_entry automations\n--     -- 5. All types support on_related_event automations\n--     -- 6. Uses utility functions for condition extraction, template merging, and metadata creation\n--     -- 7. Eliminates 100+ lines of duplicated code from original implementation\n--     -- 8. Called by: comp_core_compile\n    \n--     v_automations := p_definition->'automations';\n--     v_orchestration_stages := p_definition->'orchestration_stages'; -- New for orchestration type\n    \n--     IF v_automations IS NULL AND v_orchestration_stages IS NULL THEN -- Updated Check\n--         RETURN jsonb_build_object('rules_created', 0, 'actions_created', 0); \n--     END IF;\n    \n--     -- ** A. PROCESS ORCHESTRATION RULES (NEW BLOCK) **\n--     IF v_blueprint_type = 'orchestration' AND v_orchestration_stages IS NOT NULL THEN\n--         -- DEV NOTES: This block would contain the logic to transform \n--         -- `orchestration_stages` into `wf_rules` watching child entities. \n--         -- For a surgical approach, we acknowledge the need but keep the \n--         -- implementation separate or simple here.\n        \n--         RAISE NOTICE '[comp_artifacts_rules_actions] Generating orchestration artifacts... (placeholder)';\n--         -- Example of a minimal trigger rule generation:\n--         -- v_rule_count := v_rule_count + automation.compile_orchestration_triggers(...);\n--     END IF;\n\n--     -- ** B. PROCESS LIFECYCLE/APPROVAL AUTOMATIONS **\n--     IF v_blueprint_type IN ('lifecycle', 'approval') AND v_automations IS NOT NULL THEN\n        \n--         -- Process Stage Entry Automations\n--         v_stage_automations := v_automations->'on_stage_entry';\n--         IF v_stage_automations IS NOT NULL THEN\n--             FOR v_stage_name, v_stage_config IN SELECT key, value FROM jsonb_each(v_stage_automations) LOOP\n--                 v_actions := v_stage_config->'actions'; \n--                 v_conditions := v_stage_config->'conditions';\n--                 v_rule_name := 'Blueprint: ' || v_blueprint_name || ' - Stage ' || v_stage_name || ' Entry';\n--                 v_trigger_type := format('%s.%s.stage.%s.entered', v_entity_schema, v_entity_type, v_stage_name);\n                \n--                 -- Enhanced condition handling using standardized approach\n--                 IF v_conditions IS NULL OR v_conditions = 'null'::jsonb OR v_conditions = '{}'::jsonb THEN \n--                     v_conditions := '{\"type\": \"AND\", \"rules\": []}'::jsonb; \n--                 END IF;\n                \n--                 -- Build standardized metadata\n--                 v_metadata := automation.comp_utils_build_metadata(\n--                     p_blueprint_id, \n--                     p_version, \n--                     p_esm_def_id,\n--                     'on_stage_entry.' || v_stage_name,\n--                     jsonb_build_object(\n--                         'blueprint_name', v_blueprint_name,\n--                         'blueprint_type', v_blueprint_type\n--                     )\n--                 );\n                \n--                 -- Create Rule using utility function\n--                 v_rule_id := automation.comp_utils_create_rule(\n--                     p_organization_id, \n--                     v_rule_name, \n--                     'Auto-generated from blueprint for stage entry', \n--                     v_entity_schema, \n--                     v_entity_type, \n--                     v_trigger_type, \n--                     v_conditions, \n--                     p_version, \n--                     10, -- priority\n--                     p_blueprint_id, \n--                     v_metadata\n--                 );\n--                 v_rule_count := v_rule_count + 1;\n                \n--                 -- Create Actions for Stage Entry with optimized utility functions\n--                 FOR v_action IN SELECT * FROM jsonb_array_elements(v_actions) LOOP\n--                     v_action_priority := COALESCE((v_action->>'priority')::INT, 0);\n                    \n--                     BEGIN\n--                         -- Use utility function for condition extraction\n--                         v_action_conditions := automation.comp_utils_extract_conditions(v_action);\n                        \n--                         -- Use utility function for template variable merging\n--                         v_final_action_config := automation.comp_utils_merge_template_vars(\n--                             COALESCE(v_action->'config', '{}'::jsonb),\n--                             v_blueprint_name,\n--                             p_version\n--                         );\n                        \n--                         -- Build action metadata with condition source tracking\n--                         v_metadata := automation.comp_utils_build_metadata(\n--                             p_blueprint_id, \n--                             p_version, \n--                             p_esm_def_id,\n--                             'on_stage_entry.' || v_stage_name,\n--                             jsonb_build_object(\n--                                 'blueprint_name', v_blueprint_name,\n--                                 'blueprint_type', v_blueprint_type,\n--                                 'blueprint_action_name', v_action->>'name', \n--                                 'blueprint_action_order', v_action_priority,\n--                                 'condition_source', CASE \n--                                     WHEN v_action->'conditions' IS NOT NULL THEN 'top_level'\n--                                     WHEN v_action->'config'->'conditions' IS NOT NULL THEN 'nested_config'\n--                                     WHEN v_action->'applies_to_categories' IS NOT NULL THEN 'category_conversion'\n--                                     ELSE 'none'\n--                                 END\n--                             )\n--                         );\n                        \n--                         -- Create Action using utility function\n--                         PERFORM automation.comp_utils_create_action(\n--                             v_rule_id, \n--                             p_organization_id, \n--                             COALESCE(v_action->>'name', 'Unnamed Action'), \n--                             v_action->>'action_type', \n--                             v_final_action_config,\n--                             v_action_priority, \n--                             COALESCE((v_action->>'run_asynchronous')::BOOLEAN, false),\n--                             p_blueprint_id,\n--                             v_metadata,\n--                             COALESCE(v_action->'retry_policy', '{\"max_retries\": 3, \"retry_delay\": \"5 minutes\"}'::jsonb),\n--                             v_action_conditions\n--                         );\n--                         v_action_count := v_action_count + 1;\n                        \n--                     EXCEPTION WHEN OTHERS THEN\n--                         RAISE WARNING 'Failed to create action \"%\" for stage %: %', \n--                             v_action->>'name', v_stage_name, SQLERRM;\n--                     END;\n--                 END LOOP;\n--             END LOOP;\n--         END IF;\n        \n--     END IF; -- End of lifecycle/approval block\n\n--     -- ** C. PROCESS ON_RELATED_EVENT AUTOMATIONS (ALL TYPES) **\n--     IF v_automations IS NOT NULL AND v_automations->'on_related_event' IS NOT NULL THEN\n--         v_event_automations := v_automations->'on_related_event';\n--         FOR v_event_name, v_event_config IN SELECT key, value FROM jsonb_each(v_event_automations) LOOP\n--             v_actions := v_event_config->'actions'; \n--             v_rule_name := 'Blueprint: ' || v_blueprint_name || ' - Event: ' || v_event_name;\n--             v_trigger_schema := v_event_config->'listen_to'->>'entity_schema'; \n--             v_trigger_table  := v_event_config->'listen_to'->>'entity_type'; \n--             v_trigger_type   := v_event_config->'listen_to'->>'trigger_type';\n            \n--             -- Validate listen_to structure\n--             IF v_trigger_schema IS NULL OR v_trigger_table IS NULL OR v_trigger_type IS NULL THEN \n--                 RAISE EXCEPTION 'Invalid \"listen_to\" structure for on_related_event \"%\".', v_event_name; \n--             END IF;\n            \n--             v_conditions := v_event_config->'conditions';\n--             IF v_conditions IS NULL OR v_conditions = 'null'::jsonb OR v_conditions = '{}'::jsonb THEN \n--                 v_conditions := '{\"type\": \"AND\", \"rules\": []}'::jsonb;\n--             ELSIF jsonb_typeof(v_conditions) != 'object' OR v_conditions->>'type' IS NULL THEN \n--                 RAISE EXCEPTION 'Condition for on_related_event \"%\" must be a valid JSONB object.', v_event_name; \n--             END IF;\n            \n--             -- Build standardized metadata\n--             v_metadata := automation.comp_utils_build_metadata(\n--                 p_blueprint_id, \n--                 p_version, \n--                 p_esm_def_id,\n--                 'on_related_event.' || v_event_name,\n--                 jsonb_build_object(\n--                     'blueprint_name', v_blueprint_name,\n--                     'blueprint_type', v_blueprint_type\n--                 )\n--             );\n            \n--             -- Create Rule using utility function\n--             v_rule_id := automation.comp_utils_create_rule(\n--                 p_organization_id, \n--                 v_rule_name, \n--                 'Auto-generated from blueprint for related event', \n--                 v_trigger_schema, \n--                 v_trigger_table, \n--                 v_trigger_type, \n--                 v_conditions, \n--                 p_version, \n--                 10, -- priority\n--                 p_blueprint_id, \n--                 v_metadata\n--             );\n--             v_rule_count := v_rule_count + 1;\n            \n--             -- Create Actions for Related Event with optimized utility functions\n--             FOR v_action IN SELECT * FROM jsonb_array_elements(v_actions) LOOP\n--                 v_action_priority := COALESCE((v_action->>'priority')::INT, 0);\n                \n--                 BEGIN\n--                     -- Use utility function for condition extraction\n--                     v_action_conditions := automation.comp_utils_extract_conditions(v_action);\n                    \n--                     -- Use utility function for template variable merging\n--                     v_final_action_config := automation.comp_utils_merge_template_vars(\n--                         COALESCE(v_action->'config', '{}'::jsonb),\n--                         v_blueprint_name,\n--                         p_version\n--                     );\n                    \n--                     -- Build action metadata with condition source tracking\n--                     v_metadata := automation.comp_utils_build_metadata(\n--                         p_blueprint_id, \n--                         p_version, \n--                         p_esm_def_id,\n--                         'on_related_event.' || v_event_name,\n--                         jsonb_build_object(\n--                             'blueprint_name', v_blueprint_name,\n--                             'blueprint_type', v_blueprint_type,\n--                             'blueprint_action_name', v_action->>'name', \n--                             'blueprint_action_order', v_action_priority,\n--                             'condition_source', CASE \n--                                 WHEN v_action->'conditions' IS NOT NULL THEN 'top_level'\n--                                 WHEN v_action->'config'->'conditions' IS NOT NULL THEN 'nested_config'\n--                                 WHEN v_action->'applies_to_categories' IS NOT NULL THEN 'category_conversion'\n--                                 ELSE 'none'\n--                             END\n--                         )\n--                     );\n                    \n--                     -- Create Action using utility function\n--                     PERFORM automation.comp_utils_create_action(\n--                         v_rule_id, \n--                         p_organization_id, \n--                         COALESCE(v_action->>'name', 'Unnamed Action'), \n--                         v_action->>'action_type', \n--                         v_final_action_config,\n--                         v_action_priority, \n--                         COALESCE((v_action->>'run_asynchronous')::BOOLEAN, false),\n--                         p_blueprint_id,\n--                         v_metadata,\n--                         COALESCE(v_action->'retry_policy', '{\"max_retries\": 3, \"retry_delay\": \"5 minutes\"}'::jsonb),\n--                         v_action_conditions\n--                     );\n--                     v_action_count := v_action_count + 1;\n                    \n--                 EXCEPTION WHEN OTHERS THEN\n--                     RAISE WARNING 'Failed to create action \"%\" for event %: %', \n--                         v_action->>'name', v_event_name, SQLERRM;\n--                 END;\n--             END LOOP;\n--         END LOOP;\n--     END IF;\n    \n--     RAISE NOTICE 'Created % rules and % actions for blueprint % (type: %)', v_rule_count, v_action_count, p_blueprint_id, v_blueprint_type;\n--     RETURN jsonb_build_object('rules_created', v_rule_count, 'actions_created', v_action_count);\n-- END;\n\n-- ABOVE TRIAL FOR NON STANDARD APPROVAL\n\nDECLARE\n    v_automations JSONB; \n    v_stage_automations JSONB; \n    v_event_automations JSONB; \n    v_stage_name TEXT; \n    v_stage_config JSONB; \n    v_actions JSONB; \n    v_action JSONB; \n    v_rule_id UUID;\n    v_entity_schema TEXT := p_definition->>'entity_schema'; \n    v_entity_type TEXT := p_definition->>'entity_type'; \n    v_blueprint_name TEXT := p_definition->>'name';\n    v_trigger_schema TEXT; \n    v_trigger_table TEXT; \n    v_trigger_type TEXT; \n    v_rule_name TEXT;\n    v_conditions JSONB; \n    v_condition_type TEXT; \n    v_rule_count INT := 0; \n    v_action_count INT := 0; \n    v_event_name TEXT; \n    v_event_config JSONB; \n    v_action_priority INT;\n    v_metadata JSONB;\n    v_action_conditions JSONB;\n    v_final_action_config JSONB;\n    -- MINIMAL FIX: Add blueprint_type for metadata only\n    v_blueprint_type TEXT := COALESCE(p_definition->>'blueprint_type', 'lifecycle');\nBEGIN\n    -- DEV NOTES:\n    -- 1. Compiles rules and actions from blueprint automations with heavy optimization\n    -- 2. Uses utility functions for condition extraction, template merging, and metadata creation\n    -- 3. Eliminates 100+ lines of duplicated code from original implementation\n    -- 4. Called by: comp_core_compile\n    -- 5. MINIMAL FIX: Works for both lifecycle and approval blueprints\n    --    - If approval blueprint has automations, they'll be processed\n    --    - If approval blueprint has no automations, returns early (rules_created: 0, actions_created: 0)\n    \n    v_automations := p_definition->'automations';\n    IF v_automations IS NULL THEN \n        RETURN jsonb_build_object('rules_created', 0, 'actions_created', 0); \n    END IF;\n    \n    -- Process Stage Entry Automations (works for both lifecycle and approval)\n    v_stage_automations := v_automations->'on_stage_entry';\n    IF v_stage_automations IS NOT NULL THEN\n        FOR v_stage_name, v_stage_config IN SELECT key, value FROM jsonb_each(v_stage_automations) LOOP\n            v_actions := v_stage_config->'actions'; \n            v_conditions := v_stage_config->'conditions';\n            v_rule_name := 'Blueprint: ' || v_blueprint_name || ' - Stage ' || v_stage_name || ' Entry';\n            v_trigger_type := format('%s.%s.stage.%s.entered', v_entity_schema, v_entity_type, v_stage_name);\n            \n            -- Enhanced condition handling using standardized approach\n            IF v_conditions IS NULL OR v_conditions = 'null'::jsonb OR v_conditions = '{}'::jsonb THEN \n                v_conditions := '{\"type\": \"AND\", \"rules\": []}'::jsonb; \n            END IF;\n            \n            -- Build standardized metadata (MINIMAL FIX: add blueprint_type)\n            v_metadata := automation.comp_utils_build_metadata(\n                p_blueprint_id, \n                p_version, \n                p_esm_def_id,\n                'on_stage_entry.' || v_stage_name,\n                jsonb_build_object(\n                    'blueprint_name', v_blueprint_name,\n                    'blueprint_type', v_blueprint_type  -- MINIMAL FIX: Added\n                )\n            );\n            \n            -- Create Rule using utility function\n            v_rule_id := automation.comp_utils_create_rule(\n                p_organization_id, \n                v_rule_name, \n                'Auto-generated from blueprint for stage entry', \n                v_entity_schema, \n                v_entity_type, \n                v_trigger_type, \n                v_conditions, \n                p_version, \n                10, -- priority\n                p_blueprint_id, \n                v_metadata\n            );\n            v_rule_count := v_rule_count + 1;\n            \n            -- Create Actions for Stage Entry with optimized utility functions\n            FOR v_action IN SELECT * FROM jsonb_array_elements(v_actions) LOOP\n                v_action_priority := COALESCE((v_action->>'priority')::INT, 0);\n                \n                BEGIN\n                    -- Use utility function for condition extraction\n                    v_action_conditions := automation.comp_utils_extract_conditions(v_action);\n                    \n                    -- Use utility function for template variable merging\n                    v_final_action_config := automation.comp_utils_merge_template_vars(\n                        COALESCE(v_action->'config', '{}'::jsonb),\n                        v_blueprint_name,\n                        p_version\n                    );\n                    \n                    -- Build action metadata with condition source tracking (MINIMAL FIX: add blueprint_type)\n                    v_metadata := automation.comp_utils_build_metadata(\n                        p_blueprint_id, \n                        p_version, \n                        p_esm_def_id,\n                        'on_stage_entry.' || v_stage_name,\n                        jsonb_build_object(\n                            'blueprint_name', v_blueprint_name,\n                            'blueprint_type', v_blueprint_type,  -- MINIMAL FIX: Added\n                            'blueprint_action_name', v_action->>'name', \n                            'blueprint_action_order', v_action_priority,\n                            'condition_source', CASE \n                                WHEN v_action->'conditions' IS NOT NULL THEN 'top_level'\n                                WHEN v_action->'config'->'conditions' IS NOT NULL THEN 'nested_config'\n                                WHEN v_action->'applies_to_categories' IS NOT NULL THEN 'category_conversion'\n                                ELSE 'none'\n                            END\n                        )\n                    );\n                    \n                    -- Create Action using utility function\n                    PERFORM automation.comp_utils_create_action(\n                        v_rule_id, \n                        p_organization_id, \n                        COALESCE(v_action->>'name', 'Unnamed Action'), \n                        v_action->>'action_type', \n                        v_final_action_config,\n                        v_action_priority, \n                        COALESCE((v_action->>'run_asynchronous')::BOOLEAN, false),\n                        p_blueprint_id,\n                        v_metadata,\n                        COALESCE(v_action->'retry_policy', '{\"max_retries\": 3, \"retry_delay\": \"5 minutes\"}'::jsonb),\n                        v_action_conditions\n                    );\n                    v_action_count := v_action_count + 1;\n                    \n                EXCEPTION WHEN OTHERS THEN\n                    RAISE WARNING 'Failed to create action \"%\" for stage %: %', \n                        v_action->>'name', v_stage_name, SQLERRM;\n                END;\n            END LOOP;\n        END LOOP;\n    END IF;\n\n    -- Process Related Event Automations with same optimized approach (works for all types)\n    v_event_automations := v_automations->'on_related_event';\n    IF v_event_automations IS NOT NULL THEN\n        FOR v_event_name, v_event_config IN SELECT key, value FROM jsonb_each(v_event_automations) LOOP\n            v_actions := v_event_config->'actions'; \n            v_rule_name := 'Blueprint: ' || v_blueprint_name || ' - Event: ' || v_event_name;\n            v_trigger_schema := v_event_config->'listen_to'->>'entity_schema'; \n            v_trigger_table  := v_event_config->'listen_to'->>'entity_type'; \n            v_trigger_type   := v_event_config->'listen_to'->>'trigger_type';\n            \n            -- Validate listen_to structure\n            IF v_trigger_schema IS NULL OR v_trigger_table IS NULL OR v_trigger_type IS NULL THEN \n                RAISE EXCEPTION 'Invalid \"listen_to\" structure for on_related_event \"%\".', v_event_name; \n            END IF;\n            \n            v_conditions := v_event_config->'conditions';\n            IF v_conditions IS NULL OR v_conditions = 'null'::jsonb OR v_conditions = '{}'::jsonb THEN \n                v_conditions := '{\"type\": \"AND\", \"rules\": []}'::jsonb;\n            ELSIF jsonb_typeof(v_conditions) != 'object' OR v_conditions->>'type' IS NULL THEN \n                RAISE EXCEPTION 'Condition for on_related_event \"%\" must be a valid JSONB object.', v_event_name; \n            END IF;\n            \n            -- Build standardized metadata (MINIMAL FIX: add blueprint_type)\n            v_metadata := automation.comp_utils_build_metadata(\n                p_blueprint_id, \n                p_version, \n                p_esm_def_id,\n                'on_related_event.' || v_event_name,\n                jsonb_build_object(\n                    'blueprint_name', v_blueprint_name,\n                    'blueprint_type', v_blueprint_type  -- MINIMAL FIX: Added\n                )\n            );\n            \n            -- Create Rule using utility function\n            v_rule_id := automation.comp_utils_create_rule(\n                p_organization_id, \n                v_rule_name, \n                'Auto-generated from blueprint for related event', \n                v_trigger_schema, \n                v_trigger_table, \n                v_trigger_type, \n                v_conditions, \n                p_version, \n                10, -- priority\n                p_blueprint_id, \n                v_metadata\n            );\n            v_rule_count := v_rule_count + 1;\n            \n            -- Create Actions for Related Event with optimized utility functions\n            FOR v_action IN SELECT * FROM jsonb_array_elements(v_actions) LOOP\n                v_action_priority := COALESCE((v_action->>'priority')::INT, 0);\n                \n                BEGIN\n                    -- Use utility function for condition extraction\n                    v_action_conditions := automation.comp_utils_extract_conditions(v_action);\n                    \n                    -- Use utility function for template variable merging\n                    v_final_action_config := automation.comp_utils_merge_template_vars(\n                        COALESCE(v_action->'config', '{}'::jsonb),\n                        v_blueprint_name,\n                        p_version\n                    );\n                    \n                    -- Build action metadata with condition source tracking (MINIMAL FIX: add blueprint_type)\n                    v_metadata := automation.comp_utils_build_metadata(\n                        p_blueprint_id, \n                        p_version, \n                        p_esm_def_id,\n                        'on_related_event.' || v_event_name,\n                        jsonb_build_object(\n                            'blueprint_name', v_blueprint_name,\n                            'blueprint_type', v_blueprint_type,  -- MINIMAL FIX: Added\n                            'blueprint_action_name', v_action->>'name', \n                            'blueprint_action_order', v_action_priority,\n                            'condition_source', CASE \n                                WHEN v_action->'conditions' IS NOT NULL THEN 'top_level'\n                                WHEN v_action->'config'->'conditions' IS NOT NULL THEN 'nested_config'\n                                WHEN v_action->'applies_to_categories' IS NOT NULL THEN 'category_conversion'\n                                ELSE 'none'\n                            END\n                        )\n                    );\n                    \n                    -- Create Action using utility function\n                    PERFORM automation.comp_utils_create_action(\n                        v_rule_id, \n                        p_organization_id, \n                        COALESCE(v_action->>'name', 'Unnamed Action'), \n                        v_action->>'action_type', \n                        v_final_action_config,\n                        v_action_priority, \n                        COALESCE((v_action->>'run_asynchronous')::BOOLEAN, false),\n                        p_blueprint_id,\n                        v_metadata,\n                        COALESCE(v_action->'retry_policy', '{\"max_retries\": 3, \"retry_delay\": \"5 minutes\"}'::jsonb),\n                        v_action_conditions\n                    );\n                    v_action_count := v_action_count + 1;\n                    \n                EXCEPTION WHEN OTHERS THEN\n                    RAISE WARNING 'Failed to create action \"%\" for event %: %', \n                        v_action->>'name', v_event_name, SQLERRM;\n                END;\n            END LOOP;\n        END LOOP;\n    END IF;\n    \n    RAISE NOTICE 'Created % rules and % actions for blueprint % (type: %)', \n        v_rule_count, v_action_count, p_blueprint_id, v_blueprint_type;\n    RETURN jsonb_build_object('rules_created', v_rule_count, 'actions_created', v_action_count);\nEND;$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_artifacts_scheduled_jobs",
    "function_arguments": "p_blueprint_id uuid, p_definition jsonb, p_version integer, p_esm_def_id uuid, p_organization_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_artifacts_scheduled_jobs(p_blueprint_id uuid, p_definition jsonb, p_version integer, p_esm_def_id uuid, p_organization_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$-- -- ***** WORKED B4 BP TYPES - tested dec 9 ******** --\n\n-- DECLARE\n--     v_sla_rules JSONB;\n--     v_sla_rule JSONB;\n--     v_rule_id UUID;\n--     v_rule_name TEXT;\n--     v_entity_schema TEXT := p_definition->>'entity_schema';\n--     v_entity_type TEXT := p_definition->>'entity_type';\n--     v_blueprint_name TEXT := p_definition->>'name';\n--     v_monitored_stages JSONB;\n--     v_time_threshold_hours TEXT;\n--     v_conditions_jsonb JSONB;\n--     v_rule_conditions_payload JSONB;\n--     v_rule_count INT := 0;\n--     v_action_count INT := 0;\n--     v_job_count INT := 0;\n--     v_action_priority INT;\n--     v_sla_rule_id TEXT;\n--     v_escalation_level INT;\n--     v_on_breach_config JSONB;\n--     v_email_config JSONB;\n--     v_metadata JSONB;\n--     v_sla_action_conditions JSONB;\n--     v_on_breach_conditions JSONB;\n-- BEGIN\n--     -- DEV NOTES:\n--     -- 1. Compiles SLA rules, actions, and scheduled jobs with heavy optimization\n--     -- 2. Uses utility functions for condition extraction, template merging, and metadata creation\n--     -- 3. Eliminates 80+ lines of duplicated code from original implementation\n--     -- 4. Called by: comp_core_compile\n    \n--     RAISE NOTICE '=== Starting comp_artifacts_scheduled_jobs ===';\n--     RAISE NOTICE 'Blueprint: %, Version: %, Organization: %', p_blueprint_id, p_version, p_organization_id;\n    \n--     v_sla_rules := p_definition->'sla_rules';\n    \n--     IF v_sla_rules IS NULL OR jsonb_typeof(v_sla_rules) != 'array' OR jsonb_array_length(v_sla_rules) = 0 THEN\n--         RAISE NOTICE 'No SLA rules to process, returning early';\n--         RETURN jsonb_build_object('rules_created', 0, 'actions_created', 0, 'jobs_created', 0);\n--     END IF;\n\n--     FOR v_sla_rule IN SELECT * FROM jsonb_array_elements(v_sla_rules) \n--     LOOP\n--         v_sla_rule_id := v_sla_rule->>'id';\n--         v_rule_name := 'Blueprint SLA: ' || v_blueprint_name || ' - ' || v_sla_rule_id;\n--         v_monitored_stages := v_sla_rule->'monitored_stages';\n--         v_time_threshold_hours := COALESCE(v_sla_rule->>'time_threshold_hours', '0');\n--         v_conditions_jsonb := v_sla_rule->'conditions';\n        \n--         RAISE NOTICE 'Processing SLA rule: %', v_sla_rule_id;\n\n--         -- Validate monitored_stages\n--         IF v_monitored_stages IS NULL OR jsonb_array_length(v_monitored_stages) = 0 THEN\n--             RAISE WARNING 'Skipping SLA rule %: `monitored_stages` is missing or empty.', v_sla_rule_id;\n--             CONTINUE;\n--         END IF;\n        \n--         -- Handle empty conditions\n--         IF v_conditions_jsonb IS NULL OR v_conditions_jsonb = 'null'::jsonb THEN\n--             v_conditions_jsonb := '{\"type\": \"AND\", \"rules\": []}'::jsonb;\n--         END IF;\n\n--         -- Build rule conditions payload\n--         v_rule_conditions_payload := jsonb_build_object(\n--             'monitored_stages', v_monitored_stages,\n--             'time_threshold_hours', v_time_threshold_hours,\n--             'base_conditions', v_conditions_jsonb,\n--             'sla_rule_id', v_sla_rule_id\n--         );\n\n--         -- Calculate escalation level from on_breach configuration\n--         v_escalation_level := 1;\n--         v_on_breach_config := v_sla_rule->'on_breach';\n--         IF v_on_breach_config IS NOT NULL AND v_on_breach_config->'update_entity' IS NOT NULL THEN\n--             v_escalation_level := COALESCE(\n--                 (v_on_breach_config->'update_entity'->>'value')::INT,\n--                 1\n--             );\n--         END IF;\n\n--         -- Build standardized metadata\n--         v_metadata := automation.comp_utils_build_metadata(\n--             p_blueprint_id, \n--             p_version, \n--             p_esm_def_id,\n--             NULL, -- no specific context\n--             jsonb_build_object(\n--                 'blueprint_name', v_blueprint_name,\n--                 'blueprint_sla_rule_id', v_sla_rule_id,\n--                 'target_escalation_level', v_escalation_level\n--             )\n--         );\n\n--         -- Create the rule using utility function\n--         BEGIN\n--             v_rule_id := automation.comp_utils_create_rule(\n--                 p_organization_id, \n--                 v_rule_name, \n--                 COALESCE(v_sla_rule->>'description', 'SLA rule for ' || v_sla_rule_id),\n--                 v_entity_schema, \n--                 v_entity_type,\n--                 'scheduled', \n--                 v_rule_conditions_payload,\n--                 p_version, \n--                 20, -- priority\n--                 p_blueprint_id, \n--                 v_metadata\n--             );\n            \n--             v_rule_count := v_rule_count + 1;\n--             RAISE NOTICE '  -> Created rule: % (ID: %)', v_rule_name, v_rule_id;\n--         EXCEPTION WHEN OTHERS THEN\n--             RAISE WARNING 'Failed to create rule for SLA %: %', v_sla_rule_id, SQLERRM;\n--             CONTINUE;\n--         END;\n\n--         -- Create EMAIL action with optimized utility functions\n--         IF v_sla_rule->'action' IS NOT NULL AND v_sla_rule->'action' != 'null'::jsonb THEN\n--             BEGIN\n--                 v_action_priority := COALESCE((v_sla_rule->'action'->>'priority')::INT, 0);\n                \n--                 -- Use utility function for template variable merging\n--                 v_email_config := automation.comp_utils_merge_template_vars(\n--                     COALESCE(v_sla_rule->'action'->'config', '{}'::jsonb),\n--                     v_blueprint_name,\n--                     p_version\n--                 );\n                \n--                 -- Add SLA-specific template variables\n--                 v_email_config := jsonb_set(\n--                     v_email_config,\n--                     '{template_variables}',\n--                     COALESCE(v_email_config->'template_variables', '{}'::jsonb) || \n--                     jsonb_build_object(\n--                         'entity_id', '{{new.display_id}}',\n--                         'entity_type', v_entity_type,\n--                         'escalation_level', v_escalation_level,\n--                         'sla_rule_name', v_sla_rule_id,\n--                         'time_threshold', v_time_threshold_hours || ' hours'\n--                     )\n--                 );\n                \n--                 -- Use utility function for condition extraction\n--                 v_sla_action_conditions := automation.comp_utils_extract_conditions(v_sla_rule->'action');\n                \n--                 -- Build action metadata\n--                 v_metadata := automation.comp_utils_build_metadata(\n--                     p_blueprint_id, \n--                     p_version, \n--                     p_esm_def_id,\n--                     NULL, -- no specific context\n--                     jsonb_build_object(\n--                         'blueprint_name', v_blueprint_name,\n--                         'blueprint_sla_rule_id', v_sla_rule_id,\n--                         'blueprint_action_name', v_sla_rule->'action'->>'name',\n--                         'blueprint_action_order', v_action_priority,\n--                         'condition_source', CASE \n--                             WHEN v_sla_rule->'action'->'conditions' IS NOT NULL THEN 'top_level'\n--                             WHEN v_sla_rule->'action'->'config'->'conditions' IS NOT NULL THEN 'nested_config'\n--                             ELSE 'none'\n--                         END\n--                     )\n--                 );\n                \n--                 -- Create action using utility function\n--                 PERFORM automation.comp_utils_create_action(\n--                     v_rule_id, \n--                     p_organization_id, \n--                     COALESCE(v_sla_rule->'action'->>'name', 'SLA Action for ' || v_sla_rule_id),\n--                     v_sla_rule->'action'->>'type', \n--                     v_email_config, \n--                     v_action_priority, \n--                     false, -- run_asynchronous\n--                     p_blueprint_id,\n--                     v_metadata,\n--                     COALESCE(v_sla_rule->'action'->'retry_policy', '{\"max_retries\": 3, \"retry_delay\": \"5 minutes\"}'::jsonb),\n--                     v_sla_action_conditions\n--                 );\n                \n--                 v_action_count := v_action_count + 1;\n--                 RAISE NOTICE '  -> Created SLA email action with conditions: %', \n--                     CASE WHEN v_sla_action_conditions IS NOT NULL THEN 'YES' ELSE 'NO' END;\n--             EXCEPTION WHEN OTHERS THEN\n--                 RAISE WARNING 'Failed to create email action for SLA rule %: %', v_rule_id, SQLERRM;\n--             END;\n--         END IF;\n\n--         -- Create ON_BREACH update_entity action with optimized utility functions\n--         IF v_on_breach_config IS NOT NULL AND v_on_breach_config != 'null'::jsonb THEN\n--             IF v_on_breach_config->'update_entity' IS NOT NULL THEN\n--                 BEGIN\n--                     -- Use utility function for condition extraction\n--                     v_on_breach_conditions := automation.comp_utils_extract_conditions(v_on_breach_config->'update_entity');\n                    \n--                     -- Build action metadata\n--                     v_metadata := automation.comp_utils_build_metadata(\n--                         p_blueprint_id, \n--                         p_version, \n--                         p_esm_def_id,\n--                         NULL, -- no specific context\n--                         jsonb_build_object(\n--                             'blueprint_name', v_blueprint_name,\n--                             'blueprint_sla_rule_id', v_sla_rule_id,\n--                             'is_on_breach_action', true,\n--                             'condition_source', CASE \n--                                 WHEN v_on_breach_config->'update_entity'->'conditions' IS NOT NULL THEN 'top_level'\n--                                 WHEN v_on_breach_config->'update_entity'->'config'->'conditions' IS NOT NULL THEN 'nested_config'\n--                                 ELSE 'none'\n--                             END\n--                         )\n--                     );\n                    \n--                     -- Create action using utility function\n--                     PERFORM automation.comp_utils_create_action(\n--                         v_rule_id, \n--                         p_organization_id, \n--                         'Update Entity for SLA: ' || v_sla_rule_id,\n--                         'update_entity', \n--                         jsonb_build_object(\n--                             'entity_schema', v_entity_schema,\n--                             'entity_name', v_entity_type,\n--                             'payload', jsonb_build_object(\n--                                 (v_on_breach_config->'update_entity'->>'field'), \n--                                 (v_on_breach_config->'update_entity'->'value')\n--                             )\n--                         ),\n--                         COALESCE(v_action_priority, 0) + 1,\n--                         false, -- run_asynchronous\n--                         p_blueprint_id,\n--                         v_metadata,\n--                         '{\"max_retries\": 3, \"retry_delay\": \"5 minutes\"}'::jsonb,\n--                         v_on_breach_conditions\n--                     );\n                    \n--                     v_action_count := v_action_count + 1;\n--                     RAISE NOTICE '  -> Created on_breach action with conditions: %', \n--                         CASE WHEN v_on_breach_conditions IS NOT NULL THEN 'YES' ELSE 'NO' END;\n--                 EXCEPTION WHEN OTHERS THEN\n--                     RAISE WARNING 'Failed to create on_breach action for SLA rule %: %', v_rule_id, SQLERRM;\n--                 END;\n--             END IF;\n--         END IF;\n\n--         -- Create scheduled job\n--         BEGIN\n--             INSERT INTO automation.wf_scheduled_jobs (\n--                 organization_id, rule_id, job_type, cron_expression, \n--                 next_run, status, blueprint_id, metadata,\n--                 is_active\n--             )\n--             VALUES (\n--                 p_organization_id, v_rule_id, 'SLA_MONITOR', \n--                 COALESCE(v_sla_rule->>'check_frequency', '0 */6 * * *'),\n--                 NOW(), 'pending', p_blueprint_id, \n--                 automation.comp_utils_build_metadata(\n--                     p_blueprint_id, \n--                     p_version, \n--                     p_esm_def_id,\n--                     NULL, -- no specific context\n--                     jsonb_build_object(\n--                         'blueprint_name', v_blueprint_name,\n--                         'blueprint_sla_rule_id', v_sla_rule_id\n--                     )\n--                 ),\n--                 true\n--             );\n            \n--             v_job_count := v_job_count + 1;\n--             RAISE NOTICE '  -> Created scheduled job for rule %', v_rule_id;\n--         EXCEPTION WHEN OTHERS THEN\n--             RAISE WARNING 'Failed to create scheduled job for rule %: %', v_rule_id, SQLERRM;\n--         END;\n\n--     END LOOP;\n\n--     RAISE NOTICE '=== Completed comp_artifacts_scheduled_jobs ===';\n--     RAISE NOTICE 'Rules: %, Actions: %, Jobs: %', v_rule_count, v_action_count, v_job_count;\n    \n--     RETURN jsonb_build_object('rules_created', v_rule_count, 'actions_created', v_action_count, 'jobs_created', v_job_count);\n-- END;\n\nDECLARE\n    v_sla_rules JSONB;\n    v_sla_rule JSONB;\n    v_rule_id UUID;\n    v_rule_name TEXT;\n    v_entity_schema TEXT := p_definition->>'entity_schema';\n    v_entity_type TEXT := p_definition->>'entity_type';\n    v_blueprint_name TEXT := p_definition->>'name';\n    v_monitored_stages JSONB;\n    v_time_threshold_hours TEXT;\n    v_conditions_jsonb JSONB;\n    v_rule_conditions_payload JSONB;\n    v_rule_count INT := 0;\n    v_action_count INT := 0;\n    v_job_count INT := 0;\n    v_action_priority INT;\n    v_sla_rule_id TEXT;\n    v_escalation_level INT;\n    v_on_breach_config JSONB;\n    v_email_config JSONB;\n    v_metadata JSONB;\n    v_sla_action_conditions JSONB;\n    v_on_breach_conditions JSONB;\n    -- MINIMAL FIX: Add blueprint_type for metadata\n    v_blueprint_type TEXT := COALESCE(p_definition->>'blueprint_type', 'lifecycle');\nBEGIN\n    -- DEV NOTES:\n    -- 1. Compiles SLA rules, actions, and scheduled jobs with heavy optimization\n    -- 2. Uses utility functions for condition extraction, template merging, and metadata creation\n    -- 3. Eliminates 80+ lines of duplicated code from original implementation\n    -- 4. Called by: comp_core_compile\n    -- 5. MINIMAL FIX: Works for both lifecycle and approval blueprints with SLA rules\n    \n    RAISE NOTICE '=== Starting comp_artifacts_scheduled_jobs ===';\n    RAISE NOTICE 'Blueprint: % (type: %), Version: %, Organization: %', \n        p_blueprint_id, v_blueprint_type, p_version, p_organization_id;\n    \n    v_sla_rules := p_definition->'sla_rules';\n    \n    IF v_sla_rules IS NULL OR jsonb_typeof(v_sla_rules) != 'array' OR jsonb_array_length(v_sla_rules) = 0 THEN\n        RAISE NOTICE 'No SLA rules to process, returning early';\n        RETURN jsonb_build_object('rules_created', 0, 'actions_created', 0, 'jobs_created', 0);\n    END IF;\n\n    FOR v_sla_rule IN SELECT * FROM jsonb_array_elements(v_sla_rules) \n    LOOP\n        v_sla_rule_id := v_sla_rule->>'id';\n        v_rule_name := 'Blueprint SLA: ' || v_blueprint_name || ' - ' || v_sla_rule_id;\n        v_monitored_stages := v_sla_rule->'monitored_stages';\n        v_time_threshold_hours := COALESCE(v_sla_rule->>'time_threshold_hours', '0');\n        v_conditions_jsonb := v_sla_rule->'conditions';\n        \n        RAISE NOTICE 'Processing SLA rule: % (type: %)', v_sla_rule_id, v_blueprint_type;\n\n        -- Validate monitored_stages\n        IF v_monitored_stages IS NULL OR jsonb_array_length(v_monitored_stages) = 0 THEN\n            RAISE WARNING 'Skipping SLA rule %: `monitored_stages` is missing or empty.', v_sla_rule_id;\n            CONTINUE;\n        END IF;\n        \n        -- Handle empty conditions\n        IF v_conditions_jsonb IS NULL OR v_conditions_jsonb = 'null'::jsonb THEN\n            v_conditions_jsonb := '{\"type\": \"AND\", \"rules\": []}'::jsonb;\n        END IF;\n\n        -- Build rule conditions payload\n        v_rule_conditions_payload := jsonb_build_object(\n            'monitored_stages', v_monitored_stages,\n            'time_threshold_hours', v_time_threshold_hours,\n            'base_conditions', v_conditions_jsonb,\n            'sla_rule_id', v_sla_rule_id\n        );\n\n        -- Calculate escalation level from on_breach configuration\n        v_escalation_level := 1;\n        v_on_breach_config := v_sla_rule->'on_breach';\n        IF v_on_breach_config IS NOT NULL AND v_on_breach_config->'update_entity' IS NOT NULL THEN\n            v_escalation_level := COALESCE(\n                (v_on_breach_config->'update_entity'->>'value')::INT,\n                1\n            );\n        END IF;\n\n        -- Build standardized metadata (MINIMAL FIX: add blueprint_type)\n        v_metadata := automation.comp_utils_build_metadata(\n            p_blueprint_id, \n            p_version, \n            p_esm_def_id,\n            NULL, -- no specific context\n            jsonb_build_object(\n                'blueprint_name', v_blueprint_name,\n                'blueprint_type', v_blueprint_type,  -- MINIMAL FIX: Added\n                'blueprint_sla_rule_id', v_sla_rule_id,\n                'target_escalation_level', v_escalation_level\n            )\n        );\n\n        -- Create the rule using utility function\n        BEGIN\n            v_rule_id := automation.comp_utils_create_rule(\n                p_organization_id, \n                v_rule_name, \n                COALESCE(v_sla_rule->>'description', 'SLA rule for ' || v_sla_rule_id),\n                v_entity_schema, \n                v_entity_type,\n                'scheduled', \n                v_rule_conditions_payload,\n                p_version, \n                20, -- priority\n                p_blueprint_id, \n                v_metadata\n            );\n            \n            v_rule_count := v_rule_count + 1;\n            RAISE NOTICE '  -> Created rule: % (ID: %)', v_rule_name, v_rule_id;\n        EXCEPTION WHEN OTHERS THEN\n            RAISE WARNING 'Failed to create rule for SLA %: %', v_sla_rule_id, SQLERRM;\n            CONTINUE;\n        END;\n\n        -- Create EMAIL action with optimized utility functions\n        IF v_sla_rule->'action' IS NOT NULL AND v_sla_rule->'action' != 'null'::jsonb THEN\n            BEGIN\n                v_action_priority := COALESCE((v_sla_rule->'action'->>'priority')::INT, 0);\n                \n                -- Use utility function for template variable merging\n                v_email_config := automation.comp_utils_merge_template_vars(\n                    COALESCE(v_sla_rule->'action'->'config', '{}'::jsonb),\n                    v_blueprint_name,\n                    p_version\n                );\n                \n                -- Add SLA-specific template variables\n                v_email_config := jsonb_set(\n                    v_email_config,\n                    '{template_variables}',\n                    COALESCE(v_email_config->'template_variables', '{}'::jsonb) || \n                    jsonb_build_object(\n                        'entity_id', '{{new.display_id}}',\n                        'entity_type', v_entity_type,\n                        'escalation_level', v_escalation_level,\n                        'sla_rule_name', v_sla_rule_id,\n                        'time_threshold', v_time_threshold_hours || ' hours'\n                    )\n                );\n                \n                -- Use utility function for condition extraction\n                v_sla_action_conditions := automation.comp_utils_extract_conditions(v_sla_rule->'action');\n                \n                -- Build action metadata (MINIMAL FIX: add blueprint_type)\n                v_metadata := automation.comp_utils_build_metadata(\n                    p_blueprint_id, \n                    p_version, \n                    p_esm_def_id,\n                    NULL, -- no specific context\n                    jsonb_build_object(\n                        'blueprint_name', v_blueprint_name,\n                        'blueprint_type', v_blueprint_type,  -- MINIMAL FIX: Added\n                        'blueprint_sla_rule_id', v_sla_rule_id,\n                        'blueprint_action_name', v_sla_rule->'action'->>'name',\n                        'blueprint_action_order', v_action_priority,\n                        'condition_source', CASE \n                            WHEN v_sla_rule->'action'->'conditions' IS NOT NULL THEN 'top_level'\n                            WHEN v_sla_rule->'action'->'config'->'conditions' IS NOT NULL THEN 'nested_config'\n                            ELSE 'none'\n                        END\n                    )\n                );\n                \n                -- Create action using utility function\n                PERFORM automation.comp_utils_create_action(\n                    v_rule_id, \n                    p_organization_id, \n                    COALESCE(v_sla_rule->'action'->>'name', 'SLA Action for ' || v_sla_rule_id),\n                    v_sla_rule->'action'->>'type', \n                    v_email_config, \n                    v_action_priority, \n                    false, -- run_asynchronous\n                    p_blueprint_id,\n                    v_metadata,\n                    COALESCE(v_sla_rule->'action'->'retry_policy', '{\"max_retries\": 3, \"retry_delay\": \"5 minutes\"}'::jsonb),\n                    v_sla_action_conditions\n                );\n                \n                v_action_count := v_action_count + 1;\n                RAISE NOTICE '  -> Created SLA email action with conditions: %', \n                    CASE WHEN v_sla_action_conditions IS NOT NULL THEN 'YES' ELSE 'NO' END;\n            EXCEPTION WHEN OTHERS THEN\n                RAISE WARNING 'Failed to create email action for SLA rule %: %', v_rule_id, SQLERRM;\n            END;\n        END IF;\n\n        -- Create ON_BREACH update_entity action with optimized utility functions\n        IF v_on_breach_config IS NOT NULL AND v_on_breach_config != 'null'::jsonb THEN\n            IF v_on_breach_config->'update_entity' IS NOT NULL THEN\n                BEGIN\n                    -- Use utility function for condition extraction\n                    v_on_breach_conditions := automation.comp_utils_extract_conditions(v_on_breach_config->'update_entity');\n                    \n                    -- Build action metadata (MINIMAL FIX: add blueprint_type)\n                    v_metadata := automation.comp_utils_build_metadata(\n                        p_blueprint_id, \n                        p_version, \n                        p_esm_def_id,\n                        NULL, -- no specific context\n                        jsonb_build_object(\n                            'blueprint_name', v_blueprint_name,\n                            'blueprint_type', v_blueprint_type,  -- MINIMAL FIX: Added\n                            'blueprint_sla_rule_id', v_sla_rule_id,\n                            'is_on_breach_action', true,\n                            'condition_source', CASE \n                                WHEN v_on_breach_config->'update_entity'->'conditions' IS NOT NULL THEN 'top_level'\n                                WHEN v_on_breach_config->'update_entity'->'config'->'conditions' IS NOT NULL THEN 'nested_config'\n                                ELSE 'none'\n                            END\n                        )\n                    );\n                    \n                    -- Create action using utility function\n                    PERFORM automation.comp_utils_create_action(\n                        v_rule_id, \n                        p_organization_id, \n                        'Update Entity for SLA: ' || v_sla_rule_id,\n                        'update_entity', \n                        jsonb_build_object(\n                            'entity_schema', v_entity_schema,\n                            'entity_name', v_entity_type,\n                            'payload', jsonb_build_object(\n                                (v_on_breach_config->'update_entity'->>'field'), \n                                (v_on_breach_config->'update_entity'->'value')\n                            )\n                        ),\n                        COALESCE(v_action_priority, 0) + 1,\n                        false, -- run_asynchronous\n                        p_blueprint_id,\n                        v_metadata,\n                        '{\"max_retries\": 3, \"retry_delay\": \"5 minutes\"}'::jsonb,\n                        v_on_breach_conditions\n                    );\n                    \n                    v_action_count := v_action_count + 1;\n                    RAISE NOTICE '  -> Created on_breach action with conditions: %', \n                        CASE WHEN v_on_breach_conditions IS NOT NULL THEN 'YES' ELSE 'NO' END;\n                EXCEPTION WHEN OTHERS THEN\n                    RAISE WARNING 'Failed to create on_breach action for SLA rule %: %', v_rule_id, SQLERRM;\n                END;\n            END IF;\n        END IF;\n\n        -- Create scheduled job (MINIMAL FIX: add blueprint_type to job metadata)\n        BEGIN\n            INSERT INTO automation.wf_scheduled_jobs (\n                organization_id, rule_id, job_type, cron_expression, \n                next_run, status, blueprint_id, metadata,\n                is_active\n            )\n            VALUES (\n                p_organization_id, v_rule_id, 'SLA_MONITOR', \n                COALESCE(v_sla_rule->>'check_frequency', '0 */6 * * *'),\n                NOW(), 'pending', p_blueprint_id, \n                automation.comp_utils_build_metadata(\n                    p_blueprint_id, \n                    p_version, \n                    p_esm_def_id,\n                    NULL, -- no specific context\n                    jsonb_build_object(\n                        'blueprint_name', v_blueprint_name,\n                        'blueprint_type', v_blueprint_type,  -- MINIMAL FIX: Added\n                        'blueprint_sla_rule_id', v_sla_rule_id\n                    )\n                ),\n                true\n            );\n            \n            v_job_count := v_job_count + 1;\n            RAISE NOTICE '  -> Created scheduled job for rule %', v_rule_id;\n        EXCEPTION WHEN OTHERS THEN\n            RAISE WARNING 'Failed to create scheduled job for rule %: %', v_rule_id, SQLERRM;\n        END;\n\n    END LOOP;\n\n    RAISE NOTICE '=== Completed comp_artifacts_scheduled_jobs ===';\n    RAISE NOTICE 'Rules: %, Actions: %, Jobs: % (type: %)', \n        v_rule_count, v_action_count, v_job_count, v_blueprint_type;\n    \n    RETURN jsonb_build_object('rules_created', v_rule_count, 'actions_created', v_action_count, 'jobs_created', v_job_count);\nEND;$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_core_activate",
    "function_arguments": "p_blueprint_id uuid, p_version integer",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_core_activate(p_blueprint_id uuid, p_version integer)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    v_org_id UUID;\n    v_entity_schema TEXT;\n    v_entity_type TEXT;\n    v_all_blueprint_ids_for_entity UUID[];\n    v_activation_count INT;\nBEGIN\n    -- DEV NOTES:\n    -- 1. Enhanced activation logic with comprehensive artifact management\n    -- 2. Implements sunset strategy for smooth transitions between versions\n    -- 3. Maintains in-flight entity processing while activating new version\n    -- 4. Called by: comp_core_compile_and_activate\n    \n    -- Step 1: Find the key characteristics (org, schema, type)\n    SELECT organization_id, entity_schema, entity_type\n    INTO v_org_id, v_entity_schema, v_entity_type\n    FROM automation.bp_process_blueprints\n    WHERE id = p_blueprint_id AND version = p_version;\n\n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Blueprint version to activate (ID: %, Version: %) not found.', p_blueprint_id, p_version;\n    END IF;\n    \n    -- Step 2: Get all blueprint IDs (all versions) for this entity type\n    SELECT array_agg(id)\n    INTO v_all_blueprint_ids_for_entity\n    FROM automation.bp_process_blueprints\n    WHERE organization_id = v_org_id\n      AND entity_schema = v_entity_schema\n      AND entity_type = v_entity_type;\n      \n    IF v_all_blueprint_ids_for_entity IS NULL THEN\n        v_all_blueprint_ids_for_entity := ARRAY[]::UUID[];\n    END IF;\n\n    RAISE NOTICE '[Sunset Activate] Deactivating all old blueprints and ESM definitions for entity %.%', v_entity_schema, v_entity_type;\n\n    -- Step 3: Deactivate ALL old blueprints AND esm_definitions for this entity type\n    -- This ensures esm_orchestration_before_insert only finds the new active one.\n    UPDATE automation.bp_process_blueprints\n    SET is_active = false, updated_at = now()\n    WHERE id = ANY(v_all_blueprint_ids_for_entity);\n\n    UPDATE automation.esm_definitions\n    SET is_active = false, updated_at = now()\n    WHERE blueprint_id = ANY(v_all_blueprint_ids_for_entity);\n\n    -- *** SUNSET LOGIC ***\n    -- We deliberately DO NOT touch wf_rules, wf_actions, or wf_scheduled_jobs.\n    -- Their `is_active` status will be managed separately.\n    -- Old rules/jobs remain active to process in-flight entities.\n\n    -- Step 4: Activate the TARGET blueprint version\n    UPDATE automation.bp_process_blueprints\n    SET is_active = true, updated_at = now()\n    WHERE id = p_blueprint_id AND version = p_version;\n\n    -- Step 5: Activate the compiled artifacts for ONLY the TARGET version\n    RAISE NOTICE '[Sunset Activate] Activating target artifacts for blueprint %, version %', p_blueprint_id, p_version;\n    \n    -- Activate ESM definitions for target version\n    UPDATE automation.esm_definitions\n    SET is_active = true, updated_at = now()\n    WHERE blueprint_id = p_blueprint_id AND (metadata->>'blueprint_version')::INT = p_version;\n\n    -- Ensure all rules/actions/jobs for the NEW version are active/enabled\n    UPDATE automation.wf_rules\n    SET is_active = true, updated_at = now()\n    WHERE blueprint_id = p_blueprint_id AND (metadata->>'blueprint_version')::INT = p_version;\n\n    UPDATE automation.wf_actions\n    SET is_enabled = true, updated_at = now()\n    WHERE blueprint_id = p_blueprint_id AND (metadata->>'blueprint_version')::INT = p_version;\n    \n    UPDATE automation.wf_scheduled_jobs\n    SET is_active = true, status = 'pending', updated_at = now()\n    WHERE blueprint_id = p_blueprint_id AND (metadata->>'blueprint_version')::INT = p_version;\n\n    -- Get activation counts for reporting\n    GET DIAGNOSTICS v_activation_count = ROW_COUNT;\n    \n    RAISE NOTICE 'Activated blueprint version (ID: %, Version: %) and deactivated other blueprint/ESM definitions for entity type %.%', \n        p_blueprint_id, p_version, v_entity_schema, v_entity_type;\n        \n    RAISE NOTICE 'Activation summary: % rules, % actions, % jobs, % ESM definitions activated',\n        (SELECT COUNT(*) FROM automation.wf_rules WHERE blueprint_id = p_blueprint_id AND (metadata->>'blueprint_version')::INT = p_version AND is_active = true),\n        (SELECT COUNT(*) FROM automation.wf_actions WHERE blueprint_id = p_blueprint_id AND (metadata->>'blueprint_version')::INT = p_version AND is_enabled = true),\n        (SELECT COUNT(*) FROM automation.wf_scheduled_jobs WHERE blueprint_id = p_blueprint_id AND (metadata->>'blueprint_version')::INT = p_version AND is_active = true),\n        (SELECT COUNT(*) FROM automation.esm_definitions WHERE blueprint_id = p_blueprint_id AND (metadata->>'blueprint_version')::INT = p_version AND is_active = true);\n\nEND;\n$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_core_compile",
    "function_arguments": "p_blueprint_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_core_compile(p_blueprint_id uuid)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$-- -- -- -- -- ***** WORKED B4 BP TYPES - tested dec 9 ******** --\n\n-- DECLARE\n--     v_blueprint RECORD; \n--     v_is_valid BOOLEAN; \n--     v_esm_def_id UUID; \n--     v_compilation_id UUID := gen_random_uuid();\n--     v_start_time TIMESTAMPTZ := clock_timestamp(); \n--     v_rules_actions_result JSONB; \n--     v_scheduled_jobs_result JSONB;\n--     v_final_details JSONB; \n--     v_compiled_by UUID;\n--     v_cleanup_result JSONB;\n-- BEGIN\n--     -- DEV NOTES:\n--     -- 1. Main compilation orchestrator with enhanced optimization\n--     -- 2. Uses utility functions for cleanup, validation, and artifact compilation\n--     -- 3. Maintains comprehensive error handling and logging\n--     -- 4. Called by: comp_core_compile_and_activate\n    \n--     -- 1. Fetch blueprint with enhanced validation\n--     SELECT * INTO STRICT v_blueprint \n--     FROM automation.bp_process_blueprints \n--     WHERE id = p_blueprint_id;\n    \n--     -- 2. Enhanced blueprint structure validation using utility function\n--     PERFORM automation.comp_validate_structure(v_blueprint.definition);\n\n--     -- 3. Targeted cleanup for this version only using utility function\n--     RAISE NOTICE 'Cleaning up artifacts for Blueprint ID %, Version %...', p_blueprint_id, v_blueprint.version;\n    \n--     v_cleanup_result := automation.comp_utils_clean_artifacts(\n--         p_blueprint_id, \n--         v_blueprint.version, \n--         ARRAY['jobs', 'actions', 'rules', 'esm']  -- Clean all artifact types\n--     );\n    \n--     RAISE NOTICE 'Cleanup completed: %', v_cleanup_result;\n\n--     -- 4. Proceed with enhanced compilation pipeline\n--     BEGIN\n--         -- Validate blueprint definition\n--         v_is_valid := automation.comp_validate_definition(v_blueprint.definition);\n        \n--         -- Compile ESM definitions\n--         v_esm_def_id := automation.comp_artifacts_esm(\n--             p_blueprint_id, \n--             v_blueprint.definition, \n--             v_blueprint.version, \n--             v_blueprint.organization_id\n--         );\n        \n--         -- Compile rules and actions\n--         v_rules_actions_result := automation.comp_artifacts_rules_actions(\n--             p_blueprint_id, \n--             v_blueprint.definition, \n--             v_blueprint.version, \n--             v_esm_def_id, \n--             v_blueprint.organization_id\n--         );\n        \n--         -- Compile scheduled jobs\n--         v_scheduled_jobs_result := automation.comp_artifacts_scheduled_jobs(\n--             p_blueprint_id, \n--             v_blueprint.definition, \n--             v_blueprint.version, \n--             v_esm_def_id, \n--             v_blueprint.organization_id\n--         );\n        \n--         -- Build compilation results\n--         v_final_details := jsonb_build_object(\n--             'message', 'Blueprint compiled successfully with enhanced optimization.',\n--             'artifacts', jsonb_build_object(\n--                 'esm_definition_id', v_esm_def_id, \n--                 'rules_created', v_rules_actions_result->'rules_created',\n--                 'actions_created', v_rules_actions_result->'actions_created', \n--                 'jobs_created', v_scheduled_jobs_result->'jobs_created',\n--                 'cleanup_result', v_cleanup_result\n--             )\n--         );\n        \n--         -- Log successful compilation\n--         PERFORM automation.comp_utils_log(\n--             v_compilation_id, \n--             p_blueprint_id, \n--             v_blueprint.version, \n--             v_blueprint.organization_id, \n--             'success', \n--             v_final_details, \n--             v_start_time, \n--             clock_timestamp(), \n--             v_compiled_by\n--         );\n\n--     EXCEPTION WHEN OTHERS THEN\n--         -- Build error details\n--         v_final_details := jsonb_build_object(\n--             'message', 'Enhanced blueprint compilation failed.', \n--             'error', SQLERRM, \n--             'detail', SQLSTATE,\n--             'context', 'comp_core_compile',\n--             'blueprint_id', p_blueprint_id,\n--             'blueprint_version', COALESCE(v_blueprint.version, 0)\n--         );\n        \n--         -- Log compilation failure\n--         PERFORM automation.comp_utils_log(\n--             v_compilation_id, \n--             p_blueprint_id, \n--             COALESCE(v_blueprint.version, 0), \n--             COALESCE(v_blueprint.organization_id, '00000000-0000-0000-0000-000000000000'),\n--             'failed', \n--             v_final_details, \n--             v_start_time, \n--             clock_timestamp(), \n--             v_compiled_by\n--         );\n--         RAISE;\n--     END;\n\n--     RAISE NOTICE 'Compilation completed successfully for blueprint %: % rules, % actions, % jobs', \n--         p_blueprint_id,\n--         v_rules_actions_result->'rules_created',\n--         v_rules_actions_result->'actions_created',\n--         v_scheduled_jobs_result->'jobs_created';\n\n--     RETURN v_compilation_id;\n-- END;\n\n\n-- -- -- DECLARE\n-- -- --     v_blueprint RECORD; \n-- -- --     v_is_valid BOOLEAN; \n-- -- --     v_esm_def_id UUID; \n-- -- --     v_compilation_id UUID := gen_random_uuid();\n-- -- --     v_start_time TIMESTAMPTZ := clock_timestamp(); \n-- -- --     v_rules_actions_result JSONB; \n-- -- --     v_scheduled_jobs_result JSONB;\n-- -- --     v_final_details JSONB; \n-- -- --     v_compiled_by UUID;\n-- -- --     v_cleanup_result JSONB;\n-- -- --     -- MINIMAL FIX: Added variables for blueprint type handling\n-- -- --     v_blueprint_type TEXT;\n-- -- --     v_definition JSONB;\n-- -- -- BEGIN\n-- -- --     -- DEV NOTES:\n-- -- --     -- 1. Main compilation orchestrator with enhanced optimization\n-- -- --     -- 2. Now supports lifecycle, approval, and orchestration blueprint types\n-- -- --     -- 3. Called by: comp_core_compile_and_activate\n    \n-- -- --     -- 1. Fetch blueprint with blueprint_type\n-- -- --     SELECT \n-- -- --         *,\n-- -- --         COALESCE(blueprint_type, 'lifecycle') AS blueprint_type_fixed\n-- -- --     INTO STRICT v_blueprint \n-- -- --     FROM automation.bp_process_blueprints \n-- -- --     WHERE id = p_blueprint_id;\n    \n-- -- --     v_definition := v_blueprint.definition;\n-- -- --     v_blueprint_type := v_blueprint.blueprint_type_fixed;\n\n-- -- --     -- 2. Validate blueprint definition\n-- -- --     v_is_valid := automation.comp_validate_definition(v_definition);\n    \n-- -- --     IF NOT v_is_valid THEN\n-- -- --         RAISE EXCEPTION 'Blueprint definition validation failed';\n-- -- --     END IF;\n\n-- -- --     -- 3. Targeted cleanup for this version only using utility function\n-- -- --     RAISE NOTICE 'Cleaning up artifacts for Blueprint ID %, Version % (type: %)...', \n-- -- --         p_blueprint_id, v_blueprint.version, v_blueprint_type;\n    \n-- -- --     v_cleanup_result := automation.comp_utils_clean_artifacts(\n-- -- --         p_blueprint_id, \n-- -- --         v_blueprint.version, \n-- -- --         ARRAY['jobs', 'actions', 'rules', 'esm']  -- Clean all artifact types\n-- -- --     );\n    \n-- -- --     RAISE NOTICE 'Cleanup completed: %', v_cleanup_result;\n\n-- -- --     -- 4. Proceed with enhanced compilation pipeline\n-- -- --     BEGIN\n-- -- --         -- Compile ESM definitions (skip for orchestration/agentic)\n-- -- --         v_esm_def_id := automation.comp_artifacts_esm(\n-- -- --             p_blueprint_id, \n-- -- --             v_definition,\n-- -- --             v_blueprint.version, \n-- -- --             v_blueprint.organization_id\n-- -- --         );\n        \n-- -- --         -- Compile rules and actions\n-- -- --         v_rules_actions_result := automation.comp_artifacts_rules_actions(\n-- -- --             p_blueprint_id, \n-- -- --             v_definition,\n-- -- --             v_blueprint.version, \n-- -- --             v_esm_def_id, \n-- -- --             v_blueprint.organization_id\n-- -- --         );\n        \n-- -- --         -- Compile scheduled jobs (lifecycle only)\n-- -- --         v_scheduled_jobs_result := automation.comp_artifacts_scheduled_jobs(\n-- -- --             p_blueprint_id, \n-- -- --             v_definition,\n-- -- --             v_blueprint.version, \n-- -- --             v_esm_def_id, \n-- -- --             v_blueprint.organization_id\n-- -- --         );\n        \n-- -- --         -- Build compilation results\n-- -- --         v_final_details := jsonb_build_object(\n-- -- --             'message', 'Blueprint compiled successfully with enhanced optimization.',\n-- -- --             'blueprint_type', v_blueprint_type,\n-- -- --             'artifacts', jsonb_build_object(\n-- -- --                 'esm_definition_id', v_esm_def_id, \n-- -- --                 'rules_created', v_rules_actions_result->'rules_created',\n-- -- --                 'actions_created', v_rules_actions_result->'actions_created', \n-- -- --                 'jobs_created', v_scheduled_jobs_result->'jobs_created',\n-- -- --                 'cleanup_result', v_cleanup_result\n-- -- --             )\n-- -- --         );\n        \n-- -- --         -- Log successful compilation\n-- -- --         PERFORM automation.comp_utils_log(\n-- -- --             v_compilation_id, \n-- -- --             p_blueprint_id, \n-- -- --             v_blueprint.version, \n-- -- --             v_blueprint.organization_id, \n-- -- --             'success', \n-- -- --             v_final_details, \n-- -- --             v_start_time, \n-- -- --             clock_timestamp(), \n-- -- --             v_compiled_by\n-- -- --         );\n\n-- -- --     EXCEPTION WHEN OTHERS THEN\n-- -- --         -- Build error details\n-- -- --         v_final_details := jsonb_build_object(\n-- -- --             'message', 'Enhanced blueprint compilation failed.', \n-- -- --             'blueprint_type', v_blueprint_type,\n-- -- --             'error', SQLERRM, \n-- -- --             'detail', SQLSTATE,\n-- -- --             'context', 'comp_core_compile',\n-- -- --             'blueprint_id', p_blueprint_id,\n-- -- --             'blueprint_version', COALESCE(v_blueprint.version, 0)\n-- -- --         );\n        \n-- -- --         -- Log compilation failure\n-- -- --         PERFORM automation.comp_utils_log(\n-- -- --             v_compilation_id, \n-- -- --             p_blueprint_id, \n-- -- --             COALESCE(v_blueprint.version, 0), \n-- -- --             COALESCE(v_blueprint.organization_id, '00000000-0000-0000-0000-000000000000'),\n-- -- --             'failed', \n-- -- --             v_final_details, \n-- -- --             v_start_time, \n-- -- --             clock_timestamp(), \n-- -- --             v_compiled_by\n-- -- --         );\n-- -- --         RAISE;\n-- -- --     END;\n\n-- -- --     RAISE NOTICE 'Compilation completed successfully for blueprint % (type: %): % rules, % actions, % jobs', \n-- -- --         p_blueprint_id,\n-- -- --         v_blueprint_type,\n-- -- --         v_rules_actions_result->'rules_created',\n-- -- --         v_rules_actions_result->'actions_created',\n-- -- --         v_scheduled_jobs_result->'jobs_created';\n\n-- -- --     RETURN v_compilation_id;\n-- -- -- END;\n\n-- -- -- ABOVE TRIED TO REMOVE THE SCHEMA AND TABLE< MIGHT BE NEEDED FOR ORCHSTRATION TYPE LATER\n\nDECLARE\n    v_blueprint RECORD; \n    v_is_valid BOOLEAN; \n    v_esm_def_id UUID; \n    v_compilation_id UUID := gen_random_uuid();\n    v_start_time TIMESTAMPTZ := clock_timestamp(); \n    v_rules_actions_result JSONB; \n    v_scheduled_jobs_result JSONB;\n    v_final_details JSONB; \n    v_compiled_by UUID;\n    v_cleanup_result JSONB;\n    \n    -- Variables for blueprint type handling\n    v_blueprint_type TEXT;\n    v_definition JSONB;\nBEGIN\n    -- 1. Fetch blueprint and determine type\n    SELECT \n        bp.*,\n        COALESCE(bp.blueprint_type, 'lifecycle') AS blueprint_type_fixed\n    INTO STRICT v_blueprint \n    FROM automation.bp_process_blueprints bp\n    WHERE bp.id = p_blueprint_id;\n    \n    v_definition := v_blueprint.definition;\n    v_blueprint_type := v_blueprint.blueprint_type_fixed; -- Use the correctly resolved type\n\n    -- 2. Enhanced blueprint structure validation using utility function\n    RAISE NOTICE 'Starting structural validation (type: %)...', v_blueprint_type;\n    PERFORM automation.comp_validate_structure(v_definition);\n\n    -- 3. Targeted cleanup for this version only\n    RAISE NOTICE 'Cleaning up artifacts for Blueprint ID %, Version % (type: %)...', \n        p_blueprint_id, v_blueprint.version, v_blueprint_type;\n    \n    v_cleanup_result := automation.comp_utils_clean_artifacts(\n        p_blueprint_id, \n        v_blueprint.version, \n        ARRAY['jobs', 'actions', 'rules', 'esm']\n    );\n    \n    RAISE NOTICE 'Cleanup completed: %', v_cleanup_result;\n\n    -- 4. Proceed with enhanced compilation pipeline\n    BEGIN\n        -- Validate blueprint definition\n        v_is_valid := automation.comp_validate_definition(v_definition);\n        \n        -- Compile ESM definitions (Only for lifecycle/approval, handles light ESM logic internally)\n        IF v_blueprint_type IN ('lifecycle', 'approval') THEN\n             v_esm_def_id := automation.comp_artifacts_esm(\n                p_blueprint_id, \n                v_definition,\n                v_blueprint.version, \n                v_blueprint.organization_id\n            );\n        END IF;\n\n        -- Compile rules and actions (Covers stage entry, related events, and future orchestration logic)\n        v_rules_actions_result := automation.comp_artifacts_rules_actions(\n            p_blueprint_id, \n            v_definition,\n            v_blueprint.version, \n            v_esm_def_id, \n            v_blueprint.organization_id\n        );\n        \n        -- Compile scheduled jobs (Covers SLA rules; logic is the same for L/A types)\n        v_scheduled_jobs_result := automation.comp_artifacts_scheduled_jobs(\n            p_blueprint_id, \n            v_definition,\n            v_blueprint.version, \n            v_esm_def_id, \n            v_blueprint.organization_id\n        );\n        \n        -- Build compilation results\n        v_final_details := jsonb_build_object(\n            'message', 'Blueprint compiled successfully with enhanced optimization.',\n            'blueprint_type', v_blueprint_type, -- Include type in log details\n            'artifacts', jsonb_build_object(\n                'esm_definition_id', v_esm_def_id, \n                'rules_created', v_rules_actions_result->'rules_created',\n                'actions_created', v_rules_actions_result->'actions_created', \n                'jobs_created', v_scheduled_jobs_result->'jobs_created',\n                'cleanup_result', v_cleanup_result\n            )\n        );\n        \n        -- Log successful compilation\n        PERFORM automation.comp_utils_log(\n            v_compilation_id, \n            p_blueprint_id, \n            v_blueprint.version, \n            v_blueprint.organization_id, \n            'success', \n            v_final_details, \n            v_start_time, \n            clock_timestamp(), \n            v_compiled_by\n        );\n\n    EXCEPTION WHEN OTHERS THEN\n        -- Build error details\n        v_final_details := jsonb_build_object(\n            'message', 'Enhanced blueprint compilation failed.', \n            'blueprint_type', v_blueprint_type,\n            'error', SQLERRM, \n            'detail', SQLSTATE,\n            'context', 'comp_core_compile',\n            'blueprint_id', p_blueprint_id,\n            'blueprint_version', COALESCE(v_blueprint.version, 0)\n        );\n        \n        -- Log compilation failure\n        PERFORM automation.comp_utils_log(\n            v_compilation_id, \n            p_blueprint_id, \n            COALESCE(v_blueprint.version, 0), \n            COALESCE(v_blueprint.organization_id, '00000000-0000-0000-0000-000000000000'),\n            'failed', \n            v_final_details, \n            v_start_time, \n            clock_timestamp(), \n            v_compiled_by\n        );\n        RAISE;\n    END;\n\n    RAISE NOTICE 'Compilation completed successfully for blueprint % (type: %): % rules, % actions, % jobs', \n        p_blueprint_id,\n        v_blueprint_type,\n        v_rules_actions_result->'rules_created',\n        v_rules_actions_result->'actions_created',\n        v_scheduled_jobs_result->'jobs_created';\n\n    RETURN v_compilation_id;\nEND;$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_core_compile_and_activate",
    "function_arguments": "p_blueprint_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_core_compile_and_activate(p_blueprint_id uuid)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$-- -- -- ***** WORKED B4 BP TYPES - tested dec 9 ******** --\n-- DECLARE\n--     v_compilation_id UUID;\n--     v_version INT;\n--     v_blueprint_name TEXT;\n-- BEGIN\n--     -- DEV NOTES:\n--     -- 1. Main entry point for blueprint compilation and activation\n--     -- 2. Orchestrates the complete compilation-to-activation pipeline\n--     -- 3. Enhanced error handling and validation throughout the process\n--     -- 4. Called by: External applications and APIs\n    \n--     -- Step 0: Validate blueprint exists and is valid\n--     IF NOT EXISTS (SELECT 1 FROM automation.bp_process_blueprints WHERE id = p_blueprint_id) THEN\n--         RAISE EXCEPTION 'Blueprint with ID % not found.', p_blueprint_id;\n--     END IF;\n\n--     -- Retrieve blueprint details for logging\n--     SELECT version, definition->>'name'\n--     INTO v_version, v_blueprint_name\n--     FROM automation.bp_process_blueprints\n--     WHERE id = p_blueprint_id;\n\n--     RAISE NOTICE 'Starting compilation and activation for blueprint: % (ID: %, Version: %)', \n--         v_blueprint_name, p_blueprint_id, v_version;\n\n--     -- Step 1: Enhanced cleanup using utility function\n--     PERFORM automation.comp_utils_clean_artifacts(p_blueprint_id, v_version);\n\n--     -- Step 2: Compile with enhanced validation and optimization\n--     v_compilation_id := automation.comp_core_compile(p_blueprint_id);\n\n--     -- Step 3: Activate with improved conflict handling\n--     PERFORM automation.comp_core_activate(p_blueprint_id, v_version);\n\n--     RAISE NOTICE 'Successfully compiled and activated blueprint: % (Compilation ID: %)', \n--         v_blueprint_name, v_compilation_id;\n\n--     -- Return compilation ID for tracking\n--     RETURN v_compilation_id;\n    \n-- EXCEPTION\n--     WHEN OTHERS THEN\n--         RAISE EXCEPTION 'Blueprint compilation and activation failed for ID %: %', p_blueprint_id, SQLERRM;\n-- END;\n\n-- -- DECLARE\n-- --     v_compilation_id UUID;\n-- --     v_version INT;\n-- --     v_blueprint_name TEXT;\n-- --     v_blueprint_type TEXT;\n-- -- BEGIN\n-- --     -- Step 0: Validate blueprint exists and is valid\n-- --     IF NOT EXISTS (SELECT 1 FROM automation.bp_process_blueprints WHERE id = p_blueprint_id) THEN\n-- --         RAISE EXCEPTION 'Blueprint with ID % not found.', p_blueprint_id;\n-- --     END IF;\n\n-- --     -- Retrieve blueprint details for logging\n-- --     SELECT version, definition->>'name', definition->>'blueprint_type'\n-- --     INTO v_version, v_blueprint_name, v_blueprint_type\n-- --     FROM automation.bp_process_blueprints\n-- --     WHERE id = p_blueprint_id;\n\n-- --     RAISE NOTICE 'Starting compilation and activation for blueprint: % (ID: %, Version: %, Type: %)', \n-- --         v_blueprint_name, p_blueprint_id, v_version, v_blueprint_type;\n\n-- --     -- Step 1: Enhanced cleanup using utility function\n-- --     PERFORM automation.comp_utils_clean_artifacts(p_blueprint_id, v_version);\n\n-- --     -- Step 2: Compile with enhanced validation and optimization\n-- --     v_compilation_id := automation.comp_core_compile(p_blueprint_id);\n\n-- --     -- Step 3: Activate with improved conflict handling\n-- --     PERFORM automation.comp_core_activate(p_blueprint_id, v_version);\n\n-- --     RAISE NOTICE 'Successfully compiled and activated blueprint: % (Compilation ID: %, Type: %)', \n-- --         v_blueprint_name, v_compilation_id, v_blueprint_type;\n\n-- --     -- Return compilation ID for tracking\n-- --     RETURN v_compilation_id;\n    \n-- -- EXCEPTION\n-- --     WHEN OTHERS THEN\n-- --         RAISE EXCEPTION 'Blueprint compilation and activation failed for ID %: %', p_blueprint_id, SQLERRM;\n-- -- END;\n\n\nDECLARE\n    v_compilation_id UUID;\n    v_version INT;\n    v_blueprint_name TEXT;\n    -- Variables to capture error details\n    v_error_message TEXT;\n    v_error_context TEXT;\nBEGIN\n    -- Step 0: Validate blueprint exists and is valid\n    IF NOT EXISTS (SELECT 1 FROM automation.bp_process_blueprints WHERE id = p_blueprint_id) THEN\n        RAISE EXCEPTION 'Blueprint with ID % not found.', p_blueprint_id;\n    END IF;\n\n    -- Retrieve blueprint details for logging\n    SELECT version, definition->>'name'\n    INTO v_version, v_blueprint_name\n    FROM automation.bp_process_blueprints\n    WHERE id = p_blueprint_id;\n\n    RAISE NOTICE 'Starting compilation and activation for blueprint: % (ID: %, Version: %)', \n        v_blueprint_name, p_blueprint_id, v_version;\n\n    -- Step 1: Enhanced cleanup using utility function\n    PERFORM automation.comp_utils_clean_artifacts(p_blueprint_id, v_version);\n\n    -- Step 2: Compile with enhanced validation and optimization\n    v_compilation_id := automation.comp_core_compile(p_blueprint_id);\n\n    -- Step 3: Activate with improved conflict handling\n    PERFORM automation.comp_core_activate(p_blueprint_id, v_version);\n\n    RAISE NOTICE 'Successfully compiled and activated blueprint: % (Compilation ID: %)', \n        v_blueprint_name, v_compilation_id;\n\n    -- Return compilation ID for tracking (Successful Path)\n    RETURN v_compilation_id;\n    \nEXCEPTION\n    WHEN OTHERS THEN\n        -- Capture the actual error message and context\n        GET STACKED DIAGNOSTICS\n            v_error_message = MESSAGE_TEXT,\n            v_error_context = PG_EXCEPTION_CONTEXT;\n\n        -- Log the failure to the PostgreSQL server log\n        RAISE EXCEPTION 'COMPILATION FAILED: Blueprint ID % (v%): %', p_blueprint_id, v_version, v_error_message\n        USING HINT = v_error_context;\n\n        -- We must return a value here, even though RAISE EXCEPTION technically exits.\n        -- In most practical environments, the outer calling function catches the exception \n        -- and the database transaction aborts. We return NULL here to satisfy the function\n        -- signature if the RAISExxx fails or to be compliant, though the RAISE is the primary goal.\n        RETURN NULL; \nEND;$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_utils_build_metadata",
    "function_arguments": "p_blueprint_id uuid, p_version integer, p_esm_def_id uuid, p_context text, p_extra_fields jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_utils_build_metadata(p_blueprint_id uuid, p_version integer, p_esm_def_id uuid DEFAULT NULL::uuid, p_context text DEFAULT NULL::text, p_extra_fields jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    v_base_metadata JSONB;\n    v_final_metadata JSONB;\nBEGIN\n    -- DEV NOTES:\n    -- 1. Standardized metadata creation for all blueprint artifacts\n    -- 2. Ensures consistent field names and structure across rules, actions, jobs, ESM\n    -- 3. Supports optional context and extra fields for specific use cases\n    -- 4. Used by: comp_artifacts_esm, comp_artifacts_rules_actions, comp_artifacts_scheduled_jobs\n    \n    -- Build base metadata structure\n    v_base_metadata := jsonb_build_object(\n        'blueprint_version', p_version,\n        'blueprint_name', 'TBD' -- Will be filled by calling functions\n    );\n    \n    -- Add ESM definition ID if provided\n    IF p_esm_def_id IS NOT NULL THEN\n        v_base_metadata := v_base_metadata || jsonb_build_object('esm_definition_id', p_esm_def_id);\n    END IF;\n    \n    -- Add context if provided (e.g., 'on_stage_entry.stage_name', 'on_related_event.event_name')\n    IF p_context IS NOT NULL THEN\n        v_base_metadata := v_base_metadata || jsonb_build_object('blueprint_listener_id', p_context);\n    END IF;\n    \n    -- Merge with any extra fields provided\n    IF p_extra_fields IS NOT NULL THEN\n        v_final_metadata := v_base_metadata || p_extra_fields;\n    ELSE\n        v_final_metadata := v_base_metadata;\n    END IF;\n    \n    RETURN v_final_metadata;\nEND;\n$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_utils_clean_artifacts",
    "function_arguments": "p_blueprint_id uuid, p_version integer, p_artifact_types text[]",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_utils_clean_artifacts(p_blueprint_id uuid, p_version integer, p_artifact_types text[] DEFAULT NULL::text[])\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    v_artifact_types TEXT[];\n    v_deleted_counts JSONB := '{}'::jsonb;\n    v_count INT;\nBEGIN\n    -- DEV NOTES:\n    -- 1. Centralized cleanup for blueprint artifacts with dependency order awareness\n    -- 2. Supports selective cleanup by artifact type or full cleanup\n    -- 3. Returns deletion counts for monitoring and debugging\n    -- 4. Used by: comp_core_compile, comp_utils_cleanup (if needed)\n    \n    -- Default to cleaning all artifact types if none specified\n    v_artifact_types := COALESCE(p_artifact_types, ARRAY['jobs', 'actions', 'rules', 'esm']);\n    \n    RAISE NOTICE 'Cleaning artifacts for Blueprint %, Version %. Types: %', \n        p_blueprint_id, p_version, v_artifact_types;\n    \n    -- Clean in dependency order to avoid FK constraints\n    \n    -- 1. Scheduled Jobs (depend on rules)\n    IF 'jobs' = ANY(v_artifact_types) THEN\n        DELETE FROM automation.wf_scheduled_jobs \n        WHERE blueprint_id = p_blueprint_id \n          AND (metadata->>'blueprint_version')::INT = p_version;\n        GET DIAGNOSTICS v_count = ROW_COUNT;\n        v_deleted_counts := v_deleted_counts || jsonb_build_object('jobs', v_count);\n        RAISE NOTICE '  Deleted % scheduled jobs', v_count;\n    END IF;\n    \n    -- 2. Actions (depend on rules)  \n    IF 'actions' = ANY(v_artifact_types) THEN\n        DELETE FROM automation.wf_actions \n        WHERE blueprint_id = p_blueprint_id \n          AND (metadata->>'blueprint_version')::INT = p_version;\n        GET DIAGNOSTICS v_count = ROW_COUNT;\n        v_deleted_counts := v_deleted_counts || jsonb_build_object('actions', v_count);\n        RAISE NOTICE '  Deleted % actions', v_count;\n    END IF;\n    \n    -- 3. Rules (depend on nothing)\n    IF 'rules' = ANY(v_artifact_types) THEN\n        DELETE FROM automation.wf_rules \n        WHERE blueprint_id = p_blueprint_id \n          AND (metadata->>'blueprint_version')::INT = p_version;\n        GET DIAGNOSTICS v_count = ROW_COUNT;\n        v_deleted_counts := v_deleted_counts || jsonb_build_object('rules', v_count);\n        RAISE NOTICE '  Deleted % rules', v_count;\n    END IF;\n    \n    -- 4. ESM Definitions (depend on nothing)\n    IF 'esm' = ANY(v_artifact_types) THEN\n        DELETE FROM automation.esm_definitions \n        WHERE blueprint_id = p_blueprint_id \n          AND (metadata->>'blueprint_version')::INT = p_version;\n        GET DIAGNOSTICS v_count = ROW_COUNT;\n        v_deleted_counts := v_deleted_counts || jsonb_build_object('esm_definitions', v_count);\n        RAISE NOTICE '  Deleted % ESM definitions', v_count;\n    END IF;\n    \n    RAISE NOTICE 'Cleanup completed for Blueprint %', p_blueprint_id;\n    \n    RETURN jsonb_build_object('deleted_counts', v_deleted_counts);\nEND;\n$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_utils_create_action",
    "function_arguments": "p_rule_id uuid, p_organization_id uuid, p_action_name text, p_action_type text, p_configuration jsonb, p_action_order integer, p_run_asynchronous boolean, p_blueprint_id uuid, p_metadata jsonb, p_retry_policy jsonb, p_conditions jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_utils_create_action(p_rule_id uuid, p_organization_id uuid, p_action_name text, p_action_type text, p_configuration jsonb, p_action_order integer DEFAULT 0, p_run_asynchronous boolean DEFAULT false, p_blueprint_id uuid DEFAULT NULL::uuid, p_metadata jsonb DEFAULT NULL::jsonb, p_retry_policy jsonb DEFAULT NULL::jsonb, p_conditions jsonb DEFAULT NULL::jsonb)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    v_action_id UUID;\n    v_condition_type TEXT;\n    v_final_retry_policy JSONB;\nBEGIN\n    -- DEV NOTES:\n    -- 1. Standardized action creation with consistent field handling\n    -- 2. Automatically determines condition_type based on conditions content  \n    -- 3. Provides default retry policy if none specified\n    -- 4. Used by: comp_artifacts_rules_actions, comp_artifacts_scheduled_jobs\n    \n    -- Determine condition type\n    IF p_conditions IS NULL OR p_conditions = 'null'::jsonb THEN\n        v_condition_type := NULL;\n    ELSE\n        v_condition_type := 'jsonb';\n    END IF;\n    \n    -- Set default retry policy if not provided\n    v_final_retry_policy := COALESCE(p_retry_policy, '{\"max_retries\": 3, \"retry_delay\": \"5 minutes\"}'::jsonb);\n    \n    -- Create the action\n    INSERT INTO automation.wf_actions (\n        rule_id, organization_id, name, action_type, configuration,\n        action_order, is_enabled, run_asynchronous, blueprint_id,\n        metadata, retry_policy, conditions, condition_type\n    )\n    VALUES (\n        p_rule_id,\n        p_organization_id,\n        p_action_name,\n        p_action_type,\n        p_configuration,\n        p_action_order,\n        true,\n        p_run_asynchronous,\n        p_blueprint_id,\n        p_metadata,\n        v_final_retry_policy,\n        p_conditions,\n        v_condition_type\n    ) RETURNING id INTO v_action_id;\n    \n    RETURN v_action_id;\nEND;\n$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_utils_create_rule",
    "function_arguments": "p_organization_id uuid, p_rule_name text, p_description text, p_trigger_schema text, p_trigger_table text, p_trigger_type text, p_conditions jsonb, p_version integer, p_priority integer, p_blueprint_id uuid, p_metadata jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_utils_create_rule(p_organization_id uuid, p_rule_name text, p_description text, p_trigger_schema text, p_trigger_table text, p_trigger_type text, p_conditions jsonb, p_version integer, p_priority integer DEFAULT 10, p_blueprint_id uuid DEFAULT NULL::uuid, p_metadata jsonb DEFAULT NULL::jsonb)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    v_rule_id UUID;\n    v_condition_type TEXT;\nBEGIN\n    -- DEV NOTES:\n    -- 1. Standardized rule creation with consistent field handling\n    -- 2. Automatically determines condition_type based on conditions content\n    -- 3. Handles metadata merging and blueprint association\n    -- 4. Used by: comp_artifacts_rules_actions, comp_artifacts_scheduled_jobs\n    \n    -- Determine condition type\n    IF p_conditions IS NULL OR p_conditions = '{\"type\": \"AND\", \"rules\": []}'::jsonb THEN\n        v_condition_type := NULL;\n    ELSE\n        v_condition_type := 'jsonb';\n    END IF;\n    \n    -- Create the rule\n    INSERT INTO automation.wf_rules (\n        organization_id, name, description, trigger_schema, trigger_table,\n        trigger_type, condition_type, conditions, version, is_active,\n        priority, blueprint_id, metadata\n    )\n    VALUES (\n        p_organization_id,\n        p_rule_name,\n        p_description,\n        p_trigger_schema,\n        p_trigger_table,\n        p_trigger_type,\n        v_condition_type,\n        p_conditions,\n        p_version,\n        true,\n        p_priority,\n        p_blueprint_id,\n        p_metadata\n    ) RETURNING id INTO v_rule_id;\n    \n    RETURN v_rule_id;\nEND;\n$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_utils_extract_conditions",
    "function_arguments": "p_action_jsonb jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_utils_extract_conditions(p_action_jsonb jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    v_extracted_conditions JSONB;\n    v_applies_to_categories JSONB;\nBEGIN\n    -- DEV NOTES:\n    -- 1. Unified condition extraction from multiple possible locations in action JSON\n    -- 2. Handles both top-level and nested config conditions\n    -- 3. Converts applies_to_categories to condition format when no explicit conditions\n    -- 4. Used by: comp_artifacts_rules_actions, comp_artifacts_scheduled_jobs\n    \n    -- Step 1: Extract from primary locations (top-level takes precedence over nested)\n    v_extracted_conditions := COALESCE(\n        p_action_jsonb->'conditions',\n        p_action_jsonb->'config'->'conditions'\n    );\n    \n    -- Step 2: If no explicit conditions, check for applies_to_categories conversion\n    IF v_extracted_conditions IS NULL OR v_extracted_conditions = 'null'::jsonb THEN\n        v_applies_to_categories := p_action_jsonb->'applies_to_categories';\n        \n        IF v_applies_to_categories IS NOT NULL THEN\n            v_extracted_conditions := jsonb_build_object(\n                'type', 'AND',\n                'rules', jsonb_build_array(\n                    jsonb_build_object(\n                        'field', 'new.category_id',\n                        'operator', 'in',\n                        'value', v_applies_to_categories\n                    )\n                )\n            );\n        END IF;\n    END IF;\n    \n    RETURN v_extracted_conditions;\nEND;\n$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_utils_log",
    "function_arguments": "p_compilation_id uuid, p_blueprint_id uuid, p_blueprint_version integer, p_organization_id uuid, p_status text, p_details jsonb, p_started_at timestamp with time zone, p_finished_at timestamp with time zone, p_compiled_by uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_utils_log(p_compilation_id uuid, p_blueprint_id uuid, p_blueprint_version integer, p_organization_id uuid, p_status text, p_details jsonb, p_started_at timestamp with time zone, p_finished_at timestamp with time zone, p_compiled_by uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- DEV NOTES:\n    -- 1. Centralized compilation logging with structured details\n    -- 2. Captures both success and failure scenarios comprehensively\n    -- 3. Provides audit trail for compilation operations\n    -- 4. Used by: comp_core_compile\n    \n    INSERT INTO automation.comp_blueprint_compilation_logs (\n        id, blueprint_id, organization_id, blueprint_version, status,\n        started_at, finished_at, error_message, artifacts_generated, compiled_by,\n        metadata\n    ) VALUES (\n        p_compilation_id, \n        p_blueprint_id, \n        p_organization_id, \n        p_blueprint_version, \n        p_status,\n        p_started_at, \n        p_finished_at,\n        CASE WHEN p_status = 'failed' THEN p_details->>'error' ELSE NULL END,\n        CASE WHEN p_status = 'success' THEN p_details->'artifacts' ELSE NULL END,\n        p_compiled_by,\n        jsonb_build_object(\n            'compilation_function', 'comp_core_compile',\n            'error_context', p_details->>'context',\n            'log_version', 'v3_optimized',\n            'details', p_details\n        )\n    );\n    \n    RAISE NOTICE 'Compilation log recorded: % for blueprint % (Status: %)', \n        p_compilation_id, p_blueprint_id, p_status;\nEND;\n$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_utils_merge_template_vars",
    "function_arguments": "p_original_config jsonb, p_blueprint_name text, p_version integer",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_utils_merge_template_vars(p_original_config jsonb, p_blueprint_name text, p_version integer)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    v_merged_config JSONB;\n    v_existing_template_vars JSONB;\n    v_blueprint_template_vars JSONB;\nBEGIN\n    -- DEV NOTES:\n    -- 1. Centralized template variable merging for consistent behavior across all compilation functions\n    -- 2. Preserves existing template variables while adding blueprint metadata\n    -- 3. Only modifies template_variables if they exist in original config (non-destructive)\n    -- 4. Used by: comp_artifacts_rules_actions, comp_artifacts_scheduled_jobs\n    \n    -- Start with original config\n    v_merged_config := COALESCE(p_original_config, '{}'::jsonb);\n    \n    -- Only proceed if template_variables exist in original config\n    IF v_merged_config ? 'template_variables' THEN\n        -- Extract existing template variables\n        v_existing_template_vars := COALESCE(v_merged_config->'template_variables', '{}'::jsonb);\n        \n        -- Create blueprint metadata template variables (new values don't overwrite existing)\n        v_blueprint_template_vars := jsonb_build_object(\n            'blueprint_name', p_blueprint_name,\n            'blueprint_version', p_version::text\n        );\n        \n        -- Merge existing with blueprint vars (existing take priority)\n        v_merged_config := jsonb_set(\n            v_merged_config,\n            '{template_variables}',\n            v_existing_template_vars || v_blueprint_template_vars\n        );\n    END IF;\n    \n    -- Return merged config (unchanged if no template_variables existed)\n    RETURN v_merged_config;\nEND;\n$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_validate_actions",
    "function_arguments": "p_actions jsonb, p_path text",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_validate_actions(p_actions jsonb, p_path text)\n RETURNS boolean\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE \n    v_action JSONB;\nBEGIN\n    -- DEV NOTES:\n    -- 1. Validates action array structure and required fields\n    -- 2. Ensures all actions have name and action_type\n    -- 3. Provides detailed error context for debugging\n    -- 4. Used by: comp_validate_definition\n    \n    -- Must be a non-empty array\n    IF p_actions IS NULL OR jsonb_typeof(p_actions) != 'array' OR jsonb_array_length(p_actions) = 0 THEN \n        RAISE EXCEPTION 'Invalid actions block: Must be a non-empty array. Path: %', p_path; \n    END IF;\n    \n    -- Validate each action in the array\n    FOR v_action IN SELECT * FROM jsonb_array_elements(p_actions) LOOP\n        -- Every action must have a name\n        IF v_action->>'name' IS NULL THEN \n            RAISE EXCEPTION 'Invalid action: Action is missing \"name\". Path: %', p_path; \n        END IF;\n        \n        -- Every action must have an action_type\n        IF v_action->>'action_type' IS NULL THEN \n            RAISE EXCEPTION 'Invalid action: Action \"%\" is missing \"action_type\".', v_action->>'name'; \n        END IF;\n    END LOOP;\n    \n    RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_validate_conditions",
    "function_arguments": "p_conditions jsonb, p_path text",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_validate_conditions(p_conditions jsonb, p_path text)\n RETURNS boolean\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    v_rule JSONB;\nBEGIN\n    -- DEV NOTES:\n    -- 1. Validates condition block structure for AND/OR/NOT logic\n    -- 2. Supports nested condition groups and field-based rules\n    -- 3. Provides detailed error messages with context paths\n    -- 4. Used by: comp_validate_definition, comp_validate_actions\n    \n    -- Allow empty/null conditions (valid case)\n    IF p_conditions IS NULL OR p_conditions = 'null'::jsonb OR p_conditions = '{}'::jsonb THEN\n        RETURN TRUE;\n    END IF;\n\n    -- Must be a JSON object\n    IF jsonb_typeof(p_conditions) != 'object' THEN\n        RAISE EXCEPTION 'Invalid conditions block: Must be an object. Path: %', p_path;\n    END IF;\n\n    -- Must have valid type (AND, OR, NOT)\n    IF p_conditions->>'type' IS NULL OR NOT (p_conditions->>'type' IN ('AND', 'OR', 'NOT')) THEN\n        RAISE EXCEPTION 'Invalid conditions block: Missing or invalid \"type\" (must be AND, OR, NOT). Path: %', p_path;\n    END IF;\n\n    -- Rules must be an array\n    IF jsonb_typeof(p_conditions->'rules') != 'array' THEN\n        RAISE EXCEPTION 'Invalid conditions block: \"rules\" must be an array. Path: %', p_path;\n    END IF;\n\n    -- Validate each rule in the array\n    FOR v_rule IN SELECT * FROM jsonb_array_elements(p_conditions->'rules')\n    LOOP\n        -- Each rule must have either a 'field' (for field-based) or 'type' (for nested group)\n        IF v_rule->>'field' IS NULL AND v_rule->>'type' IS NULL THEN\n             RAISE EXCEPTION 'Invalid rule: Each rule must have a \"field\" or be a nested \"type\" group. Path: %', p_path || '->rules';\n        END IF;\n        \n        -- Field-based rules must have an operator\n        IF v_rule->>'field' IS NOT NULL AND v_rule->>'operator' IS NULL THEN\n             RAISE EXCEPTION 'Invalid rule: Rule with \"field\" is missing \"operator\". Path: %', p_path || '->rules';\n        END IF;\n    END LOOP;\n\n    RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_validate_definition",
    "function_arguments": "p_definition jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_validate_definition(p_definition jsonb)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$-- -- ***** WORKED B4 BP TYPES - tested dec 9 ******** --\n-- -- DECLARE\n-- --     v_stage_key TEXT;\n-- --     v_stage_config JSONB;\n-- --     v_event_key TEXT;\n-- --     v_event_config JSONB;\n-- --     v_sla_rule JSONB;\n-- --     v_sla_conditions JSONB; \n-- --     v_sla_conditions_type TEXT; \n-- --     v_rule_index INT := 0; \n-- --     v_sla_id TEXT;\n-- --     v_action JSONB;\n-- --     v_actions JSONB;\n-- --     v_on_breach_config JSONB;\n-- -- BEGIN\n-- --     -- DEV NOTES:\n-- --     -- 1. Comprehensive blueprint definition validation with enhanced condition checking\n-- --     -- 2. Validates automations, SLA rules, and action condition structures\n-- --     -- 3. Detects conflicting condition definitions and invalid configurations\n-- --     -- 4. Used by: comp_core_compile\n    \n-- --     -- Basic required fields validation\n-- --     IF NOT (p_definition ? 'name' AND p_definition ? 'lifecycle' AND p_definition ? 'entity_schema' AND p_definition ? 'entity_type') THEN \n-- --         RAISE EXCEPTION 'Blueprint missing required keys: name, lifecycle, entity_schema, entity_type'; \n-- --     END IF;\n\n-- --     -- Lifecycle structure validation\n-- --     IF NOT (p_definition->'lifecycle' ? 'start_stage' AND p_definition->'lifecycle' ? 'stages' \n-- --             AND jsonb_typeof(p_definition->'lifecycle'->'stages') = 'array' \n-- --             AND jsonb_array_length(p_definition->'lifecycle'->'stages') > 0) THEN \n-- --         RAISE EXCEPTION 'Blueprint lifecycle invalid: missing start_stage or stages array or stages array is empty'; \n-- --     END IF;\n\n-- --     -- Validate automations section if present\n-- --     IF p_definition->'automations' IS NOT NULL THEN\n-- --         -- Validate on_stage_entry automations\n-- --         IF p_definition->'automations'->'on_stage_entry' IS NOT NULL THEN\n-- --             FOR v_stage_key, v_stage_config IN SELECT key, value FROM jsonb_each(p_definition->'automations'->'on_stage_entry') LOOP\n-- --                 -- Validate stage conditions\n-- --                 PERFORM automation.comp_validate_conditions(\n-- --                     v_stage_config->'conditions', \n-- --                     'automations->on_stage_entry->' || v_stage_key || '->conditions'\n-- --                 );\n                \n-- --                 -- Validate stage actions\n-- --                 PERFORM automation.comp_validate_actions(\n-- --                     v_stage_config->'actions', \n-- --                     'automations->on_stage_entry->' || v_stage_key || '->actions'\n-- --                 );\n\n-- --                 -- Enhanced: Validate action-level condition structure conflicts\n-- --                 v_actions := v_stage_config->'actions';\n-- --                 IF v_actions IS NOT NULL THEN\n-- --                     FOR v_action IN SELECT * FROM jsonb_array_elements(v_actions) LOOP\n-- --                         -- Detect conflicting condition definitions\n-- --                         IF (v_action->'conditions' IS NOT NULL AND v_action->'config'->'conditions' IS NOT NULL) THEN\n-- --                             RAISE EXCEPTION 'Action \"%\" in on_stage_entry.% has conditions defined in both top-level and config. Choose one location.', \n-- --                                 COALESCE(v_action->>'name', 'unnamed'), v_stage_key;\n-- --                         END IF;\n                        \n-- --                         -- Validate condition structure if present in top-level\n-- --                         IF v_action->'conditions' IS NOT NULL THEN\n-- --                             PERFORM automation.comp_validate_conditions(\n-- --                                 v_action->'conditions', \n-- --                                 'automations->on_stage_entry->' || v_stage_key || '->actions[' || COALESCE(v_action->>'name', 'unnamed') || ']->conditions'\n-- --                             );\n-- --                         END IF;\n                        \n-- --                         -- Validate condition structure if present in nested config\n-- --                         IF v_action->'config'->'conditions' IS NOT NULL THEN\n-- --                             PERFORM automation.comp_validate_conditions(\n-- --                                 v_action->'config'->'conditions', \n-- --                                 'automations->on_stage_entry->' || v_stage_key || '->actions[' || COALESCE(v_action->>'name', 'unnamed') || ']->config->conditions'\n-- --                             );\n-- --                         END IF;\n-- --                     END LOOP;\n-- --                 END IF;\n-- --             END LOOP;\n-- --         END IF;\n        \n-- --         -- Validate on_related_event automations\n-- --         IF p_definition->'automations'->'on_related_event' IS NOT NULL THEN\n-- --             FOR v_event_key, v_event_config IN SELECT key, value FROM jsonb_each(p_definition->'automations'->'on_related_event') LOOP\n-- --                 -- Validate listen_to structure\n-- --                 IF v_event_config->'listen_to' IS NULL \n-- --                    OR v_event_config->'listen_to'->>'entity_schema' IS NULL \n-- --                    OR v_event_config->'listen_to'->>'entity_type' IS NULL \n-- --                    OR v_event_config->'listen_to'->>'trigger_type' IS NULL THEN \n-- --                     RAISE EXCEPTION 'Invalid listen_to structure for event \"%\": missing entity_schema, entity_type, or trigger_type', v_event_key; \n-- --                 END IF;\n\n-- --                 -- Validate event conditions\n-- --                 PERFORM automation.comp_validate_conditions(\n-- --                     v_event_config->'conditions', \n-- --                     'automations->on_related_event->' || v_event_key || '->conditions'\n-- --                 );\n                \n-- --                 -- Validate event actions\n-- --                 PERFORM automation.comp_validate_actions(\n-- --                     v_event_config->'actions', \n-- --                     'automations->on_related_event->' || v_event_key || '->actions'\n-- --                 );\n\n-- --                 -- Enhanced: Validate action-level condition structure conflicts\n-- --                 v_actions := v_event_config->'actions';\n-- --                 IF v_actions IS NOT NULL THEN\n-- --                     FOR v_action IN SELECT * FROM jsonb_array_elements(v_actions) LOOP\n-- --                         IF (v_action->'conditions' IS NOT NULL AND v_action->'config'->'conditions' IS NOT NULL) THEN\n-- --                             RAISE EXCEPTION 'Action \"%\" in on_related_event.% has conditions defined in both top-level and config. Choose one location.', \n-- --                                 COALESCE(v_action->>'name', 'unnamed'), v_event_key;\n-- --                         END IF;\n                        \n-- --                         IF v_action->'conditions' IS NOT NULL THEN\n-- --                             PERFORM automation.comp_validate_conditions(\n-- --                                 v_action->'conditions', \n-- --                                 'automations->on_related_event->' || v_event_key || '->actions[' || COALESCE(v_action->>'name', 'unnamed') || ']->conditions'\n-- --                             );\n-- --                         END IF;\n                        \n-- --                         IF v_action->'config'->'conditions' IS NOT NULL THEN\n-- --                             PERFORM automation.comp_validate_conditions(\n-- --                                 v_action->'config'->'conditions', \n-- --                                 'automations->on_related_event->' || v_event_key || '->actions[' || COALESCE(v_action->>'name', 'unnamed') || ']->config->conditions'\n-- --                             );\n-- --                         END IF;\n-- --                     END LOOP;\n-- --                 END IF;\n-- --             END LOOP;\n-- --         END IF;\n-- --     END IF;\n\n-- --     -- Enhanced: Validate sla_rules with action condition validation\n-- --     IF p_definition->'sla_rules' IS NOT NULL THEN\n-- --         IF jsonb_typeof(p_definition->'sla_rules') != 'array' THEN \n-- --             RAISE EXCEPTION 'sla_rules must be an array.'; \n-- --         END IF;\n        \n-- --         v_rule_index := 0; \n-- --         FOR v_sla_rule IN SELECT value FROM jsonb_array_elements(p_definition->'sla_rules') LOOP\n-- --             v_sla_id := COALESCE(v_sla_rule->>'id', 'UNKNOWN'); \n\n-- --             -- Basic SLA rule structure validation\n-- --             IF jsonb_typeof(v_sla_rule) != 'object' THEN \n-- --                 RAISE EXCEPTION 'SLA rule element at index % is not a JSON object!', v_rule_index; \n-- --             END IF;\n            \n-- --             IF v_sla_rule->>'id' IS NULL OR v_sla_rule->>'check_frequency' IS NULL OR v_sla_rule->>'time_threshold_hours' IS NULL THEN \n-- --                 RAISE EXCEPTION 'SLA rule at index % (ID: %) is missing required key(s): id, check_frequency, or time_threshold_hours', v_rule_index, v_sla_id; \n-- --             END IF;\n\n-- --             -- Validate monitored_stages\n-- --             IF v_sla_rule->'monitored_stages' IS NULL OR jsonb_array_length(v_sla_rule->'monitored_stages') = 0 THEN\n-- --                 RAISE EXCEPTION 'SLA rule ID % at index % has missing or empty monitored_stages array', v_sla_id, v_rule_index;\n-- --             END IF;\n\n-- --             -- Validate SLA conditions\n-- --             v_sla_conditions := v_sla_rule->'conditions'; \n-- --             v_sla_conditions_type := jsonb_typeof(v_sla_conditions);\n            \n-- --             IF v_sla_conditions_type != 'object' AND v_sla_conditions_type != 'null' THEN\n-- --                 RAISE EXCEPTION 'SLA rule ID % at index % has invalid \"conditions\" type. Expected object/null, got %.', v_sla_id, v_rule_index, v_sla_conditions_type;\n-- --             END IF;\n\n-- --             PERFORM automation.comp_validate_conditions(\n-- --                 v_sla_conditions, \n-- --                 'sla_rules[id=' || v_sla_id || ']->conditions'\n-- --             ); \n\n-- --             -- Enhanced: Validate SLA action conditions\n-- --             IF v_sla_rule->'action' IS NULL OR v_sla_rule->'action'->>'type' IS NULL THEN \n-- --                 RAISE EXCEPTION 'SLA rule ID % at index % is missing \"action\" or \"action.type\"', v_sla_id, v_rule_index; \n-- --             END IF;\n\n-- --             -- Validate SLA action conditions if present\n-- --             IF v_sla_rule->'action'->'conditions' IS NOT NULL THEN\n-- --                 PERFORM automation.comp_validate_conditions(\n-- --                     v_sla_rule->'action'->'conditions',\n-- --                     'sla_rules[id=' || v_sla_id || ']->action->conditions'\n-- --                 );\n-- --             END IF;\n\n-- --             -- Enhanced: Validate on_breach action conditions if present\n-- --             v_on_breach_config := v_sla_rule->'on_breach';\n-- --             IF v_on_breach_config IS NOT NULL AND v_on_breach_config != 'null'::jsonb THEN\n-- --                 IF v_on_breach_config->'update_entity' IS NOT NULL THEN\n-- --                     IF v_on_breach_config->'update_entity'->'conditions' IS NOT NULL THEN\n-- --                         PERFORM automation.comp_validate_conditions(\n-- --                             v_on_breach_config->'update_entity'->'conditions',\n-- --                             'sla_rules[id=' || v_sla_id || ']->on_breach->update_entity->conditions'\n-- --                         );\n-- --                     END IF;\n-- --                 END IF;\n-- --             END IF;\n\n-- --             v_rule_index := v_rule_index + 1; \n-- --         END LOOP;\n-- --     END IF;\n\n-- --     RAISE NOTICE 'Blueprint validation passed for: %', p_definition->>'name';\n-- --     RETURN TRUE;\n\n-- -- EXCEPTION\n-- --     WHEN OTHERS THEN\n-- --         RAISE EXCEPTION 'Blueprint validation failed: %', SQLERRM;\n-- -- END;\n\n-- -- ***** NOT WORKING _ WITHOUT ACCOMODATING STANDARDIZATION FOR APPROAVAL AND LIFECYCLE  - tested dec 9 ******** --\n\n\n-- DECLARE\n--     v_stage_key TEXT;\n--     v_stage_config JSONB;\n--     v_event_key TEXT;\n--     v_event_config JSONB;\n--     v_sla_rule JSONB;\n--     v_sla_conditions JSONB; \n--     v_sla_conditions_type TEXT; \n--     v_rule_index INT := 0; \n--     v_sla_id TEXT;\n--     v_action JSONB;\n--     v_actions JSONB;\n--     v_on_breach_config JSONB;\n--     -- DEV NOTES: Added blueprint_type support for lifecycle, approval, orchestration\n--     v_blueprint_type TEXT := COALESCE(p_definition->>'blueprint_type', 'lifecycle');\n-- BEGIN\n--     -- DEV NOTES:\n--     -- 1. Comprehensive blueprint definition validation with enhanced condition checking\n--     -- 2. Validates automations, SLA rules, and action condition structures\n--     -- 3. Detects conflicting condition definitions and invalid configurations\n--     -- 4. Supports lifecycle, approval, and orchestration blueprint types\n--     -- 5. Used by: comp_core_compile\n    \n--     -- Basic required fields validation\n--     -- NOTE: Skip lifecycle validation if approval/orchestration\n--     IF NOT (p_definition ? 'name' AND p_definition ? 'entity_schema' AND p_definition ? 'entity_type') THEN \n--         RAISE EXCEPTION 'Blueprint missing required keys: name, entity_schema, entity_type'; \n--     END IF;\n\n--     -- DEV NOTES: Conditional lifecycle structure validation based on blueprint_type\n--     -- lifecycle and approval types require stages, orchestration uses orchestration_stages\n--     IF v_blueprint_type IN ('lifecycle', 'approval') THEN\n--         -- Lifecycle structure validation\n--         IF NOT (p_definition->'lifecycle' ? 'start_stage' AND p_definition->'lifecycle' ? 'stages' \n--                 AND jsonb_typeof(p_definition->'lifecycle'->'stages') = 'array' \n--                 AND jsonb_array_length(p_definition->'lifecycle'->'stages') > 0) THEN \n--             RAISE EXCEPTION 'Blueprint lifecycle invalid: missing start_stage or stages array or stages array is empty'; \n--         END IF;\n--     END IF;\n\n--     -- DEV NOTES: New ORCHESTRATION validation - minimal structure check\n--     IF v_blueprint_type = 'orchestration' THEN\n--         IF NOT (p_definition ? 'orchestration_stages' \n--                 AND jsonb_typeof(p_definition->'orchestration_stages') = 'array' \n--                 AND jsonb_array_length(p_definition->'orchestration_stages') > 0) THEN\n--             RAISE EXCEPTION 'Orchestration blueprint missing required key: orchestration_stages array';\n--         END IF;\n--         -- NOTE: Further detailed validation of orchestration_stages would happen here but is omitted for brevity.\n--     END IF;\n\n--     -- Validate automations section if present\n--     IF p_definition->'automations' IS NOT NULL THEN\n--         -- Validate on_stage_entry automations (only for lifecycle/approval)\n--         IF v_blueprint_type IN ('lifecycle', 'approval') AND p_definition->'automations'->'on_stage_entry' IS NOT NULL THEN\n--             FOR v_stage_key, v_stage_config IN SELECT key, value FROM jsonb_each(p_definition->'automations'->'on_stage_entry') LOOP\n--                 -- Validate stage conditions\n--                 PERFORM automation.comp_validate_conditions(\n--                     v_stage_config->'conditions', \n--                     'automations->on_stage_entry->' || v_stage_key || '->conditions'\n--                 );\n                \n--                 -- Validate stage actions\n--                 PERFORM automation.comp_validate_actions(\n--                     v_stage_config->'actions', \n--                     'automations->on_stage_entry->' || v_stage_key || '->actions'\n--                 );\n\n--                 -- Enhanced: Validate action-level condition structure conflicts\n--                 v_actions := v_stage_config->'actions';\n--                 IF v_actions IS NOT NULL THEN\n--                     FOR v_action IN SELECT * FROM jsonb_array_elements(v_actions) LOOP\n--                         -- Detect conflicting condition definitions\n--                         IF (v_action->'conditions' IS NOT NULL AND v_action->'config'->'conditions' IS NOT NULL) THEN\n--                             RAISE EXCEPTION 'Action \"%\" in on_stage_entry.% has conditions defined in both top-level and config. Choose one location.', \n--                                 COALESCE(v_action->>'name', 'unnamed'), v_stage_key;\n--                         END IF;\n                        \n--                         -- Validate condition structure if present in top-level\n--                         IF v_action->'conditions' IS NOT NULL THEN\n--                             PERFORM automation.comp_validate_conditions(\n--                                 v_action->'conditions', \n--                                 'automations->on_stage_entry->' || v_stage_key || '->actions[' || COALESCE(v_action->>'name', 'unnamed') || ']->conditions'\n--                             );\n--                         END IF;\n                        \n--                         -- Validate condition structure if present in nested config\n--                         IF v_action->'config'->'conditions' IS NOT NULL THEN\n--                             PERFORM automation.comp_validate_conditions(\n--                                 v_action->'config'->'conditions', \n--                                 'automations->on_stage_entry->' || v_stage_key || '->actions[' || COALESCE(v_action->>'name', 'unnamed') || ']->config->conditions'\n--                             );\n--                         END IF;\n--                     END LOOP;\n--                 END IF;\n--             END LOOP;\n--         END IF;\n        \n--         -- Validate on_related_event automations (applicable to all blueprint types)\n--         IF p_definition->'automations'->'on_related_event' IS NOT NULL THEN\n--             FOR v_event_key, v_event_config IN SELECT key, value FROM jsonb_each(p_definition->'automations'->'on_related_event') LOOP\n--                 -- Validate listen_to structure\n--                 IF v_event_config->'listen_to' IS NULL \n--                    OR v_event_config->'listen_to'->>'entity_schema' IS NULL \n--                    OR v_event_config->'listen_to'->>'entity_type' IS NULL \n--                    OR v_event_config->'listen_to'->>'trigger_type' IS NULL THEN \n--                     RAISE EXCEPTION 'Invalid listen_to structure for event \"%\": missing entity_schema, entity_type, or trigger_type', v_event_key; \n--                 END IF;\n\n--                 -- Validate event conditions\n--                 PERFORM automation.comp_validate_conditions(\n--                     v_event_config->'conditions', \n--                     'automations->on_related_event->' || v_event_key || '->conditions'\n--                 );\n                \n--                 -- Validate event actions\n--                 PERFORM automation.comp_validate_actions(\n--                     v_event_config->'actions', \n--                     'automations->on_related_event->' || v_event_key || '->actions'\n--                 );\n\n--                 -- Enhanced: Validate action-level condition structure conflicts\n--                 v_actions := v_event_config->'actions';\n--                 IF v_actions IS NOT NULL THEN\n--                     FOR v_action IN SELECT * FROM jsonb_array_elements(v_actions) LOOP\n--                         IF (v_action->'conditions' IS NOT NULL AND v_action->'config'->'conditions' IS NOT NULL) THEN\n--                             RAISE EXCEPTION 'Action \"%\" in on_related_event.% has conditions defined in both top-level and config. Choose one location.', \n--                                 COALESCE(v_action->>'name', 'unnamed'), v_event_key;\n--                         END IF;\n                        \n--                         IF v_action->'conditions' IS NOT NULL THEN\n--                             PERFORM automation.comp_validate_conditions(\n--                                 v_action->'conditions', \n--                                 'automations->on_related_event->' || v_event_key || '->actions[' || COALESCE(v_action->>'name', 'unnamed') || ']->conditions'\n--                             );\n--                         END IF;\n                        \n--                         IF v_action->'config'->'conditions' IS NOT NULL THEN\n--                             PERFORM automation.comp_validate_conditions(\n--                                 v_action->'config'->'conditions', \n--                                 'automations->on_related_event->' || v_event_key || '->actions[' || COALESCE(v_action->>'name', 'unnamed') || ']->config->conditions'\n--                             );\n--                         END IF;\n--                     END LOOP;\n--                 END IF;\n--             END LOOP;\n--         END IF;\n--     END IF;\n\n--     -- Enhanced: Validate sla_rules with action condition validation\n--     IF p_definition->'sla_rules' IS NOT NULL THEN\n--         IF jsonb_typeof(p_definition->'sla_rules') != 'array' THEN \n--             RAISE EXCEPTION 'sla_rules must be an array.'; \n--         END IF;\n        \n--         v_rule_index := 0; \n--         FOR v_sla_rule IN SELECT value FROM jsonb_array_elements(p_definition->'sla_rules') LOOP\n--             v_sla_id := COALESCE(v_sla_rule->>'id', 'UNKNOWN'); \n\n--             -- Basic SLA rule structure validation\n--             IF jsonb_typeof(v_sla_rule) != 'object' THEN \n--                 RAISE EXCEPTION 'SLA rule element at index % is not a JSON object!', v_rule_index; \n--             END IF;\n            \n--             IF v_sla_rule->>'id' IS NULL OR v_sla_rule->>'check_frequency' IS NULL OR v_sla_rule->>'time_threshold_hours' IS NULL THEN \n--                 RAISE EXCEPTION 'SLA rule at index % (ID: %) is missing required key(s): id, check_frequency, or time_threshold_hours', v_rule_index, v_sla_id; \n--             END IF;\n\n--             -- Validate monitored_stages\n--             IF v_sla_rule->'monitored_stages' IS NULL OR jsonb_array_length(v_sla_rule->'monitored_stages') = 0 THEN\n--                 RAISE EXCEPTION 'SLA rule ID % at index % has missing or empty monitored_stages array', v_sla_id, v_rule_index;\n--             END IF;\n\n--             -- Validate SLA conditions\n--             v_sla_conditions := v_sla_rule->'conditions'; \n--             v_sla_conditions_type := jsonb_typeof(v_sla_conditions);\n            \n--             IF v_sla_conditions_type != 'object' AND v_sla_conditions_type != 'null' THEN\n--                 RAISE EXCEPTION 'SLA rule ID % at index % has invalid \"conditions\" type. Expected object/null, got %.', v_sla_id, v_rule_index, v_sla_conditions_type;\n--             END IF;\n\n--             PERFORM automation.comp_validate_conditions(\n--                 v_sla_conditions, \n--                 'sla_rules[id=' || v_sla_id || ']->conditions'\n--             ); \n\n--             -- Enhanced: Validate SLA action conditions\n--             IF v_sla_rule->'action' IS NULL OR v_sla_rule->'action'->>'type' IS NULL THEN \n--                 RAISE EXCEPTION 'SLA rule ID % at index % is missing \"action\" or \"action.type\"', v_sla_id, v_rule_index; \n--             END IF;\n\n--             -- Validate SLA action conditions if present\n--             IF v_sla_rule->'action'->'conditions' IS NOT NULL THEN\n--                 PERFORM automation.comp_validate_conditions(\n--                     v_sla_rule->'action'->'conditions',\n--                     'sla_rules[id=' || v_sla_id || ']->action->conditions'\n--                 );\n--             END IF;\n\n--             -- Enhanced: Validate on_breach action conditions if present\n--             v_on_breach_config := v_sla_rule->'on_breach';\n--             IF v_on_breach_config IS NOT NULL AND v_on_breach_config != 'null'::jsonb THEN\n--                 IF v_on_breach_config->'update_entity' IS NOT NULL THEN\n--                     IF v_on_breach_config->'update_entity'->'conditions' IS NOT NULL THEN\n--                         PERFORM automation.comp_validate_conditions(\n--                             v_on_breach_config->'update_entity'->'conditions',\n--                             'sla_rules[id=' || v_sla_id || ']->on_breach->update_entity->conditions'\n--                         );\n--                     END IF;\n--                 END IF;\n--             END IF;\n\n--             v_rule_index := v_rule_index + 1; \n--         END LOOP;\n--     END IF;\n\n--     RAISE NOTICE 'Blueprint validation passed for: % (type: %)', p_definition->>'name', v_blueprint_type;\n--     RETURN TRUE;\n\n-- EXCEPTION\n--     WHEN OTHERS THEN\n--         RAISE EXCEPTION 'Blueprint validation failed: %', SQLERRM;\n-- END;\n\n-- Modified basic validation to be type-specific\n-- Lifecycle blueprints still require entity_schema and entity_type in JSON\n-- Approval blueprints only require name in JSON\n-- All other validation logic remains unchanged\nDECLARE\n    v_stage_key TEXT;\n    v_stage_config JSONB;\n    v_event_key TEXT;\n    v_event_config JSONB;\n    v_sla_rule JSONB;\n    v_sla_conditions JSONB;\n    v_sla_conditions_type TEXT;\n    v_rule_index INT := 0;\n    v_sla_id TEXT;\n    v_action JSONB;\n    v_actions JSONB;\n    v_on_breach_config JSONB;\n    -- MINIMAL FIX: Add blueprint_type variable for logging and conditional checks\n    v_blueprint_type TEXT := COALESCE(p_definition->>'blueprint_type', 'lifecycle');\nBEGIN\n    -- Basic required fields validation (No change needed here; it passes for both types)\n    IF NOT (p_definition ? 'name' AND p_definition ? 'lifecycle' AND p_definition ? 'entity_schema' AND p_definition ? 'entity_type') THEN \n        RAISE EXCEPTION 'Blueprint missing required keys: name, lifecycle, entity_schema, entity_type (type: %)', v_blueprint_type; \n    END IF;\n\n    -- Lifecycle structure validation (No change needed here; both types use this structure)\n    IF NOT (p_definition->'lifecycle' ? 'start_stage' AND p_definition->'lifecycle' ? 'stages' \n             AND jsonb_typeof(p_definition->'lifecycle'->'stages') = 'array' \n             AND jsonb_array_length(p_definition->'lifecycle'->'stages') > 0) THEN \n        RAISE EXCEPTION 'Blueprint lifecycle invalid: missing start_stage or stages array or stages array is empty (type: %)', v_blueprint_type; \n    END IF;\n\n    -- Validate automations section if present (Logic remains the same as it correctly calls sub-validation functions)\n    IF p_definition->'automations' IS NOT NULL THEN\n        -- Validate on_stage_entry automations\n        IF p_definition->'automations'->'on_stage_entry' IS NOT NULL THEN\n            FOR v_stage_key, v_stage_config IN SELECT key, value FROM jsonb_each(p_definition->'automations'->'on_stage_entry') LOOP\n                -- Validate stage conditions\n                PERFORM automation.comp_validate_conditions(\n                    v_stage_config->'conditions', \n                    'automations->on_stage_entry->' || v_stage_key || '->conditions'\n                );\n                \n                -- Validate stage actions\n                PERFORM automation.comp_validate_actions(\n                    v_stage_config->'actions', \n                    'automations->on_stage_entry->' || v_stage_key || '->actions'\n                );\n\n                -- Enhanced: Validate action-level condition structure conflicts\n                v_actions := v_stage_config->'actions';\n                IF v_actions IS NOT NULL THEN\n                    FOR v_action IN SELECT * FROM jsonb_array_elements(v_actions) LOOP\n                        -- Detect conflicting condition definitions\n                        IF (v_action->'conditions' IS NOT NULL AND v_action->'config'->'conditions' IS NOT NULL) THEN\n                            RAISE EXCEPTION 'Action \"%\" in on_stage_entry.% has conditions defined in both top-level and config. Choose one location.', \n                                COALESCE(v_action->>'name', 'unnamed'), v_stage_key;\n                        END IF;\n                        \n                        -- Validate condition structure if present in top-level\n                        IF v_action->'conditions' IS NOT NULL THEN\n                            PERFORM automation.comp_validate_conditions(\n                                v_action->'conditions', \n                                'automations->on_stage_entry->' || v_stage_key || '->actions[' || COALESCE(v_action->>'name', 'unnamed') || ']->conditions'\n                            );\n                        END IF;\n                        \n                        -- Validate condition structure if present in nested config\n                        IF v_action->'config'->'conditions' IS NOT NULL THEN\n                            PERFORM automation.comp_validate_conditions(\n                                v_action->'config'->'conditions', \n                                'automations->on_stage_entry->' || v_stage_key || '->actions[' || COALESCE(v_action->>'name', 'unnamed') || ']->config->conditions'\n                            );\n                        END IF;\n                    END LOOP;\n                END IF;\n            END LOOP;\n        END IF;\n        \n        -- Validate on_related_event automations\n        IF p_definition->'automations'->'on_related_event' IS NOT NULL THEN\n            FOR v_event_key, v_event_config IN SELECT key, value FROM jsonb_each(p_definition->'automations'->'on_related_event') LOOP\n                -- Validate listen_to structure\n                IF v_event_config->'listen_to' IS NULL \n                   OR v_event_config->'listen_to'->>'entity_schema' IS NULL \n                   OR v_event_config->'listen_to'->>'entity_type' IS NULL \n                   OR v_event_config->'listen_to'->>'trigger_type' IS NULL THEN \n                    RAISE EXCEPTION 'Invalid listen_to structure for event \"%\": missing entity_schema, entity_type, or trigger_type', v_event_key; \n                END IF;\n\n                -- Validate event conditions\n                PERFORM automation.comp_validate_conditions(\n                    v_event_config->'conditions', \n                    'automations->on_related_event->' || v_event_key || '->conditions'\n                );\n                \n                -- Validate event actions\n                PERFORM automation.comp_validate_actions(\n                    v_event_config->'actions', \n                    'automations->on_related_event->' || v_event_key || '->actions'\n                );\n\n                -- Enhanced: Validate action-level condition structure conflicts\n                v_actions := v_event_config->'actions';\n                IF v_actions IS NOT NULL THEN\n                    FOR v_action IN SELECT * FROM jsonb_array_elements(v_actions) LOOP\n                        IF (v_action->'conditions' IS NOT NULL AND v_action->'config'->'conditions' IS NOT NULL) THEN\n                            RAISE EXCEPTION 'Action \"%\" in on_related_event.% has conditions defined in both top-level and config. Choose one location.', \n                                COALESCE(v_action->>'name', 'unnamed'), v_event_key;\n                        END IF;\n                        \n                        IF v_action->'conditions' IS NOT NULL THEN\n                            PERFORM automation.comp_validate_conditions(\n                                v_action->'conditions', \n                                'automations->on_related_event->' || v_event_key || '->actions[' || COALESCE(v_action->>'name', 'unnamed') || ']->conditions'\n                            );\n                        END IF;\n                        \n                        IF v_action->'config'->'conditions' IS NOT NULL THEN\n                            PERFORM automation.comp_validate_conditions(\n                                v_action->'config'->'conditions', \n                                'automations->on_related_event->' || v_event_key || '->actions[' || COALESCE(v_action->>'name', 'unnamed') || ']->config->conditions'\n                            );\n                        END IF;\n                    END LOOP;\n                END IF;\n            END LOOP;\n        END IF;\n    END IF;\n\n    -- Enhanced: Validate sla_rules with action condition validation\n    IF p_definition->'sla_rules' IS NOT NULL THEN\n        IF jsonb_typeof(p_definition->'sla_rules') != 'array' THEN \n            RAISE EXCEPTION 'sla_rules must be an array.'; \n        END IF;\n        \n        v_rule_index := 0; \n        FOR v_sla_rule IN SELECT value FROM jsonb_array_elements(p_definition->'sla_rules') LOOP\n            v_sla_id := COALESCE(v_sla_rule->>'id', 'UNKNOWN'); \n\n            -- Basic SLA rule structure validation\n            IF jsonb_typeof(v_sla_rule) != 'object' THEN \n                RAISE EXCEPTION 'SLA rule element at index % is not a JSON object!', v_rule_index; \n            END IF;\n            \n            IF v_sla_rule->>'id' IS NULL OR v_sla_rule->>'check_frequency' IS NULL OR v_sla_rule->>'time_threshold_hours' IS NULL THEN \n                RAISE EXCEPTION 'SLA rule at index % (ID: %) is missing required key(s): id, check_frequency, or time_threshold_hours', v_rule_index, v_sla_id; \n            END IF;\n\n            -- Validate monitored_stages\n            IF v_sla_rule->'monitored_stages' IS NULL OR jsonb_array_length(v_sla_rule->'monitored_stages') = 0 THEN\n                RAISE EXCEPTION 'SLA rule ID % at index % has missing or empty monitored_stages array', v_sla_id, v_rule_index;\n            END IF;\n\n            -- Validate SLA conditions\n            v_sla_conditions := v_sla_rule->'conditions'; \n            v_sla_conditions_type := jsonb_typeof(v_sla_conditions);\n            \n            IF v_sla_conditions_type != 'object' AND v_sla_conditions_type != 'null' THEN\n                RAISE EXCEPTION 'SLA rule ID % at index % has invalid \"conditions\" type. Expected object/null, got %.', v_sla_id, v_rule_index, v_sla_conditions_type;\n            END IF;\n\n            PERFORM automation.comp_validate_conditions(\n                v_sla_conditions, \n                'sla_rules[id=' || v_sla_id || ']->conditions'\n            ); \n\n            -- Enhanced: Validate SLA action conditions\n            IF v_sla_rule->'action' IS NULL OR v_sla_rule->'action'->>'type' IS NULL THEN \n                RAISE EXCEPTION 'SLA rule ID % at index % is missing \"action\" or \"action.type\"', v_sla_id, v_rule_index; \n            END IF;\n\n            -- Validate SLA action conditions if present\n            IF v_sla_rule->'action'->'conditions' IS NOT NULL THEN\n                PERFORM automation.comp_validate_conditions(\n                    v_sla_rule->'action'->'conditions',\n                    'sla_rules[id=' || v_sla_id || ']->action->conditions'\n                );\n            END IF;\n\n            -- Enhanced: Validate on_breach action conditions if present\n            v_on_breach_config := v_sla_rule->'on_breach';\n            IF v_on_breach_config IS NOT NULL AND v_on_breach_config != 'null'::jsonb THEN\n                IF v_on_breach_config->'update_entity' IS NOT NULL THEN\n                    IF v_on_breach_config->'update_entity'->'conditions' IS NOT NULL THEN\n                        PERFORM automation.comp_validate_conditions(\n                            v_on_breach_config->'update_entity'->'conditions',\n                            'sla_rules[id=' || v_sla_id || ']->on_breach->update_entity->conditions'\n                        );\n                    END IF;\n                END IF;\n            END IF;\n\n            v_rule_index := v_rule_index + 1; \n        END LOOP;\n    END IF;\n\n    RAISE NOTICE 'Blueprint validation passed for: % (type: %)', p_definition->>'name', v_blueprint_type;\n    RETURN TRUE;\n\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Blueprint validation failed: %', SQLERRM;\nEND;$function$\n"
  },
  {
    "schema_name": "automation",
    "function_name": "comp_validate_structure",
    "function_arguments": "p_definition jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION automation.comp_validate_structure(p_definition jsonb)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$-- -- ***** WORKED B4 BP TYPES - tested dec 9 - REVERTED BACK ******** --\nBEGIN\n    -- DEV NOTES:\n    -- 1. Structural validation beyond JSON schema - checks business logic constraints\n    -- 2. Validates stage ID uniqueness and required field presence\n    -- 3. Early detection of blueprint structural issues before compilation\n    -- 4. Used by: comp_core_compile\n    \n    -- Check for required top-level fields\n    IF NOT (p_definition ? 'name' AND p_definition ? 'entity_schema' AND p_definition ? 'entity_type') THEN\n        RAISE EXCEPTION 'Blueprint missing required fields: name, entity_schema, entity_type';\n    END IF;\n    \n    -- Validate lifecycle structure exists\n    IF p_definition->'lifecycle' IS NULL THEN\n        RAISE EXCEPTION 'Blueprint missing lifecycle definition';\n    END IF;\n    \n    -- Check for stage ID conflicts (no duplicates)\n    IF EXISTS (\n        SELECT 1 FROM (\n            SELECT value->>'id' as stage_id, COUNT(*)\n            FROM jsonb_array_elements(p_definition->'lifecycle'->'stages')\n            GROUP BY value->>'id'\n            HAVING COUNT(*) > 1\n        ) duplicates\n    ) THEN\n        RAISE EXCEPTION 'Duplicate stage IDs found in lifecycle stages';\n    END IF;\n    \n    -- Validate template variable usage in actions (placeholder for future enhancement)\n    -- This can be expanded later for template variable validation\n    \n    RAISE NOTICE 'Blueprint structure validation passed for: %', p_definition->>'name';\n    RETURN TRUE;\n    \nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Blueprint structure validation failed: %', SQLERRM;\nEND;\n\n-- -- UPDATE DID NOT WORK PROPERLY\n-- DECLARE\n--     v_blueprint_type TEXT := COALESCE(p_definition->>'blueprint_type', 'lifecycle');\n-- BEGIN\n--     -- DEV NOTES:\n--     -- 1. Validates basic blueprint structure\n--     -- 2. Called early in compilation pipeline\n--     -- 3. Ensures required fields are present\n--     -- 4. MINIMAL FIX: Added blueprint_type awareness\n    \n--     -- Basic required fields validation - TYPE SPECIFIC\n--     IF v_blueprint_type = 'lifecycle' THEN\n--         -- Lifecycle requires all fields\n--         IF NOT (p_definition ? 'name' AND p_definition ? 'entity_schema' AND p_definition ? 'entity_type') THEN \n--             RAISE EXCEPTION 'Lifecycle blueprint missing required fields: name, entity_schema, entity_type'; \n--         END IF;\n--     ELSIF v_blueprint_type = 'approval' THEN\n--         -- Approval only requires name\n--         IF NOT (p_definition ? 'name') THEN \n--             RAISE EXCEPTION 'Approval blueprint missing required field: name'; \n--         END IF;\n--         -- Entity info should already be in definition for approval blueprints\n--     ELSIF v_blueprint_type = 'orchestration' THEN\n--         -- Orchestration only requires name\n--         IF NOT (p_definition ? 'name') THEN \n--             RAISE EXCEPTION 'Orchestration blueprint missing required field: name'; \n--         END IF;\n--     ELSE\n--         -- Default validation for unknown types\n--         IF NOT (p_definition ? 'name') THEN \n--             RAISE EXCEPTION 'Blueprint missing required field: name'; \n--         END IF;\n--     END IF;\n    \n--     RAISE NOTICE 'Blueprint structure validation passed for: % (type: %)', p_definition->>'name', v_blueprint_type;\n-- END;$function$\n"
  }
]